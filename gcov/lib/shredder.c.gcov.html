<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - lib/shredder.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">lib</a> - shredder.c<span style="font-size: 80%;"> (source / <a href="shredder.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">762</td>
            <td class="headerCovTableEntry">808</td>
            <td class="headerCovTableEntryHi">94.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-05-07</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  This file is part of rmlint.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  rmlint is free software: you can redistribute it and/or modify
<span class="lineNum">       5 </span>            :  *  it under the terms of the GNU General Public License as published by
<span class="lineNum">       6 </span>            :  *  the Free Software Foundation, either version 3 of the License, or
<span class="lineNum">       7 </span>            :  *  (at your option) any later version.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *  rmlint is distributed in the hope that it will be useful,
<span class="lineNum">      10 </span>            :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      11 </span>            :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      12 </span>            :  *  GNU General Public License for more details.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  *  You should have received a copy of the GNU General Public License
<span class="lineNum">      15 </span>            :  *  along with rmlint.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * Authors:
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  *  - Christopher &lt;sahib&gt; Pahl 2010-2015 (https://github.com/sahib)
<span class="lineNum">      20 </span>            :  *  - Daniel &lt;SeeSpotRun&gt; T.   2014-2015 (https://github.com/SeeSpotRun)
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * Hosted on http://github.com/sahib/rmlint
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &lt;glib.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;sys/uio.h&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;checksum.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;preprocess.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;utilities.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;formats.h&quot;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &quot;shredder.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;xattr.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /* Enable extra debug messages? */
<span class="lineNum">      44 </span>            : #define _RM_SHRED_DEBUG 0
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : /* This is the scheduler of rmlint.
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * Files are compared in progressive &quot;generations&quot; to identify matching
<span class="lineNum">      49 </span>            :  * clusters:
<span class="lineNum">      50 </span>            :  * Generation 0: Same size files
<span class="lineNum">      51 </span>            :  * Generation 1: Same size and same hash of first  ~16kB
<span class="lineNum">      52 </span>            :  * Generation 2: Same size and same hash of first  ~50MB
<span class="lineNum">      53 </span>            :  * Generation 3: Same size and same hash of first ~100MB
<span class="lineNum">      54 </span>            :  * Generation 3: Same size and same hash of first ~150MB
<span class="lineNum">      55 </span>            :  * ... and so on until the end of the file is reached.
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * The default step size can be configured below.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  * The step size algorithm has some adaptive logic and may shorten
<span class="lineNum">      60 </span>            :  * or increase the step size if (a) a few extra MB will get to the end
<span class="lineNum">      61 </span>            :  * of the file, or (b) there is a fragmented file which has a file
<span class="lineNum">      62 </span>            :  * fragment ending within a few MB of the default read increment.
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  *
<span class="lineNum">      65 </span>            :  * The clusters and generations look something like this:
<span class="lineNum">      66 </span>            :  *
<span class="lineNum">      67 </span>            :  *+-------------------------------------------------------------------------+
<span class="lineNum">      68 </span>            :  *|     Initial list after filtering and preprocessing                      |
<span class="lineNum">      69 </span>            :  *+-------------------------------------------------------------------------+
<span class="lineNum">      70 </span>            :  *          | same size                   | same size           | same size
<span class="lineNum">      71 </span>            :  *   +------------------+           +------------------+    +----------------+
<span class="lineNum">      72 </span>            :  *   |   ShredGroup 1   |           |   ShredGroup 2   |    |   ShredGroup 3 |
<span class="lineNum">      73 </span>            :  *   |F1,F2,F3,F4,F5,F6 |           |F7,F8,F9,F10,F11  |    |   F12,F13      |
<span class="lineNum">      74 </span>            :  *   +------------------+           +------------------+    +----------------+
<span class="lineNum">      75 </span>            :  *       |            |                 |            |
<span class="lineNum">      76 </span>            :  *  +------------+ +----------+     +------------+  +---------+  +----+ +----+
<span class="lineNum">      77 </span>            :  *  | Child 1.1  | |Child 1.2 |     | Child 2.1  |  |Child 2.2|  |3.1 | |3.2 |
<span class="lineNum">      78 </span>            :  *  | F1,F3,F6   | |F2,F4,F5  |     |F7,F8,F9,F10|  |  F11    |  |F12 | |F13 |
<span class="lineNum">      79 </span>            :  *  |(hash=hash1 | |(hash=h2) |     |(hash=h3)   |  |(hash=h4)|  |(h5)| |(h6)|
<span class="lineNum">      80 </span>            :  *  +------------+ +----------+     +------------+  +---------+  +----+ +----+
<span class="lineNum">      81 </span>            :  *       |            |                |        |              \       \
<span class="lineNum">      82 </span>            :  *   +----------+ +-----------+  +-----------+ +-----------+    free!   free!
<span class="lineNum">      83 </span>            :  *   |Child1.1.1| |Child 1.2.1|  |Child 2.2.1| |Child 2.2.2|
<span class="lineNum">      84 </span>            :  *   |F1,F3,F6  | |F2,F4,F5   |  |F7,F9,F10  | |   F8      |
<span class="lineNum">      85 </span>            :  *   +----------+ +-----------+  +-----------+ +-----------+
<span class="lineNum">      86 </span>            :  *               \             \              \             \
<span class="lineNum">      87 </span>            :  *                rm!           rm!            rm!           free!
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  *
<span class="lineNum">      90 </span>            :  * The basic workflow is:
<span class="lineNum">      91 </span>            :  * 1. Pick a file from the device_queue
<span class="lineNum">      92 </span>            :  * 2. Hash the next increment
<span class="lineNum">      93 </span>            :  * 3. Check back with the file's parent to see if there is a child RmShredGroup with
<span class="lineNum">      94 </span>            :  *    matching hash; if not then create a new one.
<span class="lineNum">      95 </span>            :  * 4. Add the file into the child RmShredGroup and unlink it from its parent(see note
<span class="lineNum">      96 </span>            :  *    below on Unlinking from Parent)
<span class="lineNum">      97 </span>            :  * 5. Check if the child RmShredGroup meets criteria for hashing; if no then loop
<span class="lineNum">      98 </span>            :  *    back to (1) for another file to hash
<span class="lineNum">      99 </span>            :  * 6. If file meets criteria and is not finished hash then loop back to 2 and
<span class="lineNum">     100 </span>            :  *    hash its next increment
<span class="lineNum">     101 </span>            :  * 7. If file meets criteria and is fully hashed then flag it as ready for post-
<span class="lineNum">     102 </span>            :  *    processing (possibly via paranoid check).  Note that post-processing can't
<span class="lineNum">     103 </span>            :  *    start until the RmShredGroup's parent is dead (because new siblings may still
<span class="lineNum">     104 </span>            :  *    be coming).
<span class="lineNum">     105 </span>            :  *
<span class="lineNum">     106 </span>            :  * In the above example, the hashing order will end up being something like:
<span class="lineNum">     107 </span>            :  * F1.1 F2.1 (F3.1,F3.2), (F4.1,F4.2), (F5.1,F5.2)...
<span class="lineNum">     108 </span>            :  *                ^            ^            ^
<span class="lineNum">     109 </span>            :  *  (^ indicates where hashing could continue on to a second increment because there
<span class="lineNum">     110 </span>            :  *         was already a matching file after the first increment)
<span class="lineNum">     111 </span>            :  *
<span class="lineNum">     112 </span>            :  * The threading looks somewhat like this for two devices:
<span class="lineNum">     113 </span>            :  *
<span class="lineNum">     114 </span>            :  *                          +----------+
<span class="lineNum">     115 </span>            :  *                          | Finisher |
<span class="lineNum">     116 </span>            :  *                          |  Thread  |
<span class="lineNum">     117 </span>            :  *                          |  incl    |
<span class="lineNum">     118 </span>            :  *                          | paranoid |
<span class="lineNum">     119 </span>            :  *                          +----------+
<span class="lineNum">     120 </span>            :  *                                ^
<span class="lineNum">     121 </span>            :  *                                |
<span class="lineNum">     122 </span>            :  *                        +--------------+
<span class="lineNum">     123 </span>            :  *                        | Matched      |
<span class="lineNum">     124 </span>            :  *                        | fully-hashed |
<span class="lineNum">     125 </span>            :  *                        | dupe groups  |
<span class="lineNum">     126 </span>            :  *    Device #1           +--------------+      Device #2
<span class="lineNum">     127 </span>            :  *                               ^
<span class="lineNum">     128 </span>            :  * +-------------------+         |           +------------------+
<span class="lineNum">     129 </span>            :  * | +-------------+   |    +-----------+    | +-------------+  |
<span class="lineNum">     130 </span>            :  * | | Devlist Mgr |&lt;-------+--Push to--+-----&gt;| Devlist Mgr |  |
<span class="lineNum">     131 </span>            :  * | +-------------+   |    |  device   |    | +-------------+  |
<span class="lineNum">     132 </span>            :  * | pop from          |    |  queues   |    |        pop from  |
<span class="lineNum">     133 </span>            :  * |  queue            |    |           |    |         queue    |
<span class="lineNum">     134 </span>            :  * |     |             |    |ShredGroups|    |            |     |
<span class="lineNum">     135 </span>            :  * |     |&lt;--Continue  |    | (Matched  |    | Continue--&gt;|     |
<span class="lineNum">     136 </span>            :  * |     |      ^      |    |  partial  |    |    ^       |     |
<span class="lineNum">     137 </span>            :  * |     v      |      |    |  hashes)  |    |    |       v     |
<span class="lineNum">     138 </span>            :  * |   Read     Y      |    |           |    |    Y      Read   |
<span class="lineNum">     139 </span>            :  * |     |      |      |    |    make   |    |    |       |     |
<span class="lineNum">     140 </span>            :  * |     |   Partial------N----&gt; new &lt;---------Partial    |     |
<span class="lineNum">     141 </span>            :  * |     |    Match?   |    |   group   |    | Match?     |     |
<span class="lineNum">     142 </span>            :  * |     |      ^      |    |     ^     |    |    ^       |     |
<span class="lineNum">     143 </span>            :  * +-----|------|------+    +-----|-----+    +----|-------|-----+
<span class="lineNum">     144 </span>            :  *       v      |                 |               |       v
<span class="lineNum">     145 </span>            :  *    +----------+      +------------------+     +----------+
<span class="lineNum">     146 </span>            :  *    | Hasher   |      |Initial file list |     | Hasher   |
<span class="lineNum">     147 </span>            :  *    |(1 thread)|      |                  |     |(1 thread)|
<span class="lineNum">     148 </span>            :  *    +----------+      +------------------+     +----------+
<span class="lineNum">     149 </span>            :  *
<span class="lineNum">     150 </span>            :  * Every subbox left and right are the task that are performed.
<span class="lineNum">     151 </span>            :  *
<span class="lineNum">     152 </span>            :  * The Devlist Managers, Hashers and Finisher run as separate threads
<span class="lineNum">     153 </span>            :  * managed by GThreadPool.
<span class="lineNum">     154 </span>            :  *
<span class="lineNum">     155 </span>            :  * The Devlist Managers work sequentially through the queue of hashing
<span class="lineNum">     156 </span>            :  * jobs, sorted in order of disk offset in order to reduce seek times.
<span class="lineNum">     157 </span>            :  * On init every device gets it's own thread. This thread spawns it own
<span class="lineNum">     158 </span>            :  * hasher thread from another GTHreadPool.
<span class="lineNum">     159 </span>            :  *
<span class="lineNum">     160 </span>            :  * The Devlist Manager calls the reader function to read one file at a
<span class="lineNum">     161 </span>            :  * time using readv(). The buffers for it come from a central buffer pool
<span class="lineNum">     162 </span>            :  * that allocates some and just reuses them over and over. The buffers
<span class="lineNum">     163 </span>            :  * which contain the read data are pushed to the hasher thread, where
<span class="lineNum">     164 </span>            :  * the data-block is hashed into file-&gt;digest.  The buffer is released
<span class="lineNum">     165 </span>            :  * back to the pool after use.
<span class="lineNum">     166 </span>            :  *
<span class="lineNum">     167 </span>            :  * Once the hasher is done, the file is sent back to the Devlist Manager
<span class="lineNum">     168 </span>            :  * via a GAsyncQueue.  The Devlist Manager does a quick check to see if
<span class="lineNum">     169 </span>            :  * it can continue with the same file; if not then the file is released
<span class="lineNum">     170 </span>            :  * back to the RmShredGroups and a new file taken from the device queue.
<span class="lineNum">     171 </span>            :  *
<span class="lineNum">     172 </span>            :  *
<span class="lineNum">     173 </span>            :  * The RmShredGroups don't have a thread managing them, instead the individual
<span class="lineNum">     174 </span>            :  * Devlist Managers write to the RmShredGroups under mutex protection.
<span class="lineNum">     175 </span>            :  *
<span class="lineNum">     176 </span>            :  *
<span class="lineNum">     177 </span>            :  * The initial (&quot;foreground&quot;) thread waits for the Devlist Managers to
<span class="lineNum">     178 </span>            :  * finish their sequential walk through the files.  If there are still
<span class="lineNum">     179 </span>            :  * files to process on the device, the initial thread sends them back to
<span class="lineNum">     180 </span>            :  * the GThreadPool for another pass through the files (starting from the
<span class="lineNum">     181 </span>            :  * lowest disk offset again).
<span class="lineNum">     182 </span>            :  *
<span class="lineNum">     183 </span>            :  * Note re Unlinking a file from parent (this is the most thread-risky
<span class="lineNum">     184 </span>            :  * part of the operation so sequencing needs to be clear):
<span class="lineNum">     185 </span>            :  * * Decrease parent's child_file counter; if that is zero then check if
<span class="lineNum">     186 </span>            :  * the parent's parent is dead; if yes then kill the parent.
<span class="lineNum">     187 </span>            :  * * When killing the parent, tell all its children RMGroups that they
<span class="lineNum">     188 </span>            :  * are now orphans (which may mean it is now time for some of them to
<span class="lineNum">     189 </span>            :  * die too).
<span class="lineNum">     190 </span>            :  * Note that we need to be careful here to avoid threadlock, eg:
<span class="lineNum">     191 </span>            :  *    Child file 1 on device 1 has finished an increment.  It takes a look on its new
<span class="lineNum">     192 </span>            :  *    RmGroup so that it can add itself.  It then locks its parent RmShredGroup so that
<span class="lineNum">     193 </span>            :  *    it can do the unlinking.  If it turns out it is time for the parent to die, we
<span class="lineNum">     194 </span>            :  *    we need to lock each of its children so that we can make them orphans:
<span class="lineNum">     195 </span>            :  *        Q: What if another one of its other children was also trying to unlink?
<span class="lineNum">     196 </span>            :  *        A: No problem, can't happen (since parent can't be ready to die if it has
<span class="lineNum">     197 </span>            :  *           any active children left)
<span class="lineNum">     198 </span>            :  *        Q: What about the mutex loop from this child which is doing the unlinking?
<span class="lineNum">     199 </span>            :  *        A: No problem, either unlock the child's mutex before calling parent unlink,
<span class="lineNum">     200 </span>            :  *           or handle the calling child differently from the other children
<span class="lineNum">     201 </span>            : *
<span class="lineNum">     202 </span>            : * Below some performance controls are listed that may impact performance.
<span class="lineNum">     203 </span>            : * Controls are sorted by subjectve importanceness.
<span class="lineNum">     204 </span>            : */
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : ////////////////////////////////////////////
<span class="lineNum">     207 </span>            : // OPTIMISATION PARAMETERS FOR DECIDING   //
<span class="lineNum">     208 </span>            : // HOW MANY BYTES TO READ BEFORE STOPPING //
<span class="lineNum">     209 </span>            : // TO COMPARE PROGRESSIVE HASHES          //
<span class="lineNum">     210 </span>            : ////////////////////////////////////////////
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /* How many milliseconds to sleep if we encounter an empty file queue.
<span class="lineNum">     213 </span>            :  * This prevents a &quot;starving&quot; RmShredDevice from hogging cpu and cluttering up
<span class="lineNum">     214 </span>            :  * debug messages by continually recycling back to the joiner.
<span class="lineNum">     215 </span>            :  */
<span class="lineNum">     216 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">     217 </span>            : #define SHRED_EMPTYQUEUE_SLEEP_US (60 * 1000 * 1000) /* 60 seconds */
<span class="lineNum">     218 </span>            : #else
<span class="lineNum">     219 </span>            : #define SHRED_EMPTYQUEUE_SLEEP_US (50 * 1000) /* 0.05 second */
<span class="lineNum">     220 </span>            : #endif
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : /* how many pages can we read in (seek_time)/(CHEAP)? (use for initial read) */
<span class="lineNum">     223 </span>            : #define SHRED_BALANCED_PAGES (4)
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : /* How large a single page is (typically 4096 bytes but not always)*/
<span class="lineNum">     226 </span>            : #define SHRED_PAGE_SIZE (sysconf(_SC_PAGESIZE))
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : #define SHRED_MAX_READ_FACTOR \
<span class="lineNum">     229 </span>            :     ((256 * 1024 * 1024) / SHRED_BALANCED_PAGES / SHRED_PAGE_SIZE)
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : /* Wether to use buffered fread() or direct preadv()
<span class="lineNum">     232 </span>            :  * The latter is preferred, since it's slightly faster on linux.
<span class="lineNum">     233 </span>            :  * Other platforms may have different results though or not even have preadv.
<span class="lineNum">     234 </span>            :  * */
<span class="lineNum">     235 </span>            : #define SHRED_USE_BUFFERED_READ (0)
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : /* Flags for the fadvise() call that tells the kernel
<span class="lineNum">     238 </span>            :  * what we want to do with the file.
<span class="lineNum">     239 </span>            :  */
<span class="lineNum">     240 </span>            : #define SHRED_FADVISE_FLAGS                                      \
<span class="lineNum">     241 </span>            :     (0 | POSIX_FADV_SEQUENTIAL /* Read from 0 to file-size    */ \
<span class="lineNum">     242 </span>            :      | POSIX_FADV_WILLNEED     /* Tell the kernel to readhead */ \
<span class="lineNum">     243 </span>            :      | POSIX_FADV_NOREUSE      /* We will not reuse old data  */ \
<span class="lineNum">     244 </span>            :      )
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : ////////////////////////
<span class="lineNum">     247 </span>            : //  MATHS SHORTCUTS   //
<span class="lineNum">     248 </span>            : ////////////////////////
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : #define DIVIDE_CEIL(n, m) ((n) / (m) + !!((n) % (m)))
<span class="lineNum">     251 </span>            : #define SIGN_DIFF(X, Y) (((X) &gt; (Y)) - ((X) &lt; (Y))) /* handy for comparing unit64's */
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : ///////////////////////////////////////////////////////////////////////
<span class="lineNum">     254 </span>            : //    INTERNAL STRUCTURES, WITH THEIR INITIALISERS AND DESTROYERS    //
<span class="lineNum">     255 </span>            : ///////////////////////////////////////////////////////////////////////
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /////////// RmBufferPool and RmBuffer ////////////////
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : typedef struct RmBufferPool {
<span class="lineNum">     260 </span>            :     /* Place where the buffers are stored */
<span class="lineNum">     261 </span>            :     GTrashStack *stack;
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :     /* how many buffers are available? */
<span class="lineNum">     264 </span>            :     RmOff size;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :     /* concurrent accesses may happen */
<span class="lineNum">     267 </span>            :     GMutex lock;
<span class="lineNum">     268 </span>            : } RmBufferPool;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : /* Represents one block of read data */
<span class="lineNum">     271 </span>            : typedef struct RmBuffer {
<span class="lineNum">     272 </span>            :     /* file structure the data belongs to */
<span class="lineNum">     273 </span>            :     RmFile *file;
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /* len of the read input */
<span class="lineNum">     276 </span>            :     guint32 len;
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     /* flag to indicate that there is no more data for the current hash increment */
<span class="lineNum">     279 </span>            :     bool finished : 1;
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :     /* *must* be last member of RmBuffer,
<span class="lineNum">     282 </span>            :      * gets all the rest of the allocated space
<span class="lineNum">     283 </span>            :      * */
<span class="lineNum">     284 </span>            :     guint8 data[];
<span class="lineNum">     285 </span>            : } RmBuffer;
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : /////////* The main extra data for the scheduler *///////////
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : typedef struct RmShredTag {
<span class="lineNum">     290 </span>            :     RmSession *session;
<span class="lineNum">     291 </span>            :     RmBufferPool *mem_pool;
<span class="lineNum">     292 </span>            :     GAsyncQueue *device_return;
<span class="lineNum">     293 </span>            :     GMutex hash_mem_mtx;
<span class="lineNum">     294 </span>            :     gint64 hash_mem_alloc; /* how much memory to allocate for paranoid checks */
<span class="lineNum">     295 </span>            :     gint32
<span class="lineNum">     296 </span>            :         active_groups; /* how many shred groups active (only used with paranoid a.t.m.) */
<span class="lineNum">     297 </span>            :     GThreadPool *device_pool;
<span class="lineNum">     298 </span>            :     GAsyncQueue *hash_pool_pool;
<span class="lineNum">     299 </span>            :     GThreadPool *result_pool;
<span class="lineNum">     300 </span>            :     gint32 page_size;
<span class="lineNum">     301 </span>            :     bool mem_refusing;
<span class="lineNum">     302 </span>            : } RmShredTag;
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /////////// RmShredDevice ////////////////
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : typedef struct RmShredDevice {
<span class="lineNum">     307 </span>            :     /* queue of files awaiting (partial) hashing, sorted by disk offset.  Note
<span class="lineNum">     308 </span>            :      * this can be written to be other threads so requires mutex protection */
<span class="lineNum">     309 </span>            :     GQueue *file_queue;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :     /* Counters, used to determine when there is nothing left to do.  These
<span class="lineNum">     312 </span>            :      * can get written to by other device threads so require mutex protection */
<span class="lineNum">     313 </span>            :     gint32 remaining_files;
<span class="lineNum">     314 </span>            :     gint64 remaining_bytes;
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :     /* True when actual shreddiner began.
<span class="lineNum">     317 </span>            :      * This is used to update the correct progressbar state.
<span class="lineNum">     318 </span>            :      */
<span class="lineNum">     319 </span>            :     bool after_preprocess : 1;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     /* Lock for all of the above */
<span class="lineNum">     322 </span>            :     GMutex lock;
<span class="lineNum">     323 </span>            :     GCond change;
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :     /* disk type; allows optimisation of parameters for rotational or non- */
<span class="lineNum">     326 </span>            :     bool is_rotational;
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     /* Return queue for files which have finished the current increment */
<span class="lineNum">     329 </span>            :     GAsyncQueue *hashed_file_return;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     /* disk identification, for debugging info only */
<span class="lineNum">     332 </span>            :     char *disk_name;
<span class="lineNum">     333 </span>            :     dev_t disk;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     /* head position information, to optimise selection of next file */
<span class="lineNum">     336 </span>            :     RmOff current_offset;
<span class="lineNum">     337 </span>            :     dev_t current_dev;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :     /* size of one page, cached, so
<span class="lineNum">     340 </span>            :      * sysconf() does not need to be called always.
<span class="lineNum">     341 </span>            :      */
<span class="lineNum">     342 </span>            :     RmOff page_size;
<span class="lineNum">     343 </span>            :     RmShredTag *main;
<span class="lineNum">     344 </span>            : } RmShredDevice;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : typedef enum RmShredGroupStatus {
<span class="lineNum">     347 </span>            :     RM_SHRED_GROUP_DORMANT = 0,
<span class="lineNum">     348 </span>            :     RM_SHRED_GROUP_START_HASHING,
<span class="lineNum">     349 </span>            :     RM_SHRED_GROUP_HASHING,
<span class="lineNum">     350 </span>            :     RM_SHRED_GROUP_FINISHING,
<span class="lineNum">     351 </span>            :     RM_SHRED_GROUP_FINISHED
<span class="lineNum">     352 </span>            : } RmShredGroupStatus;
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : #define NEEDS_PREF(group)                            \
<span class="lineNum">     355 </span>            :     (group-&gt;main-&gt;session-&gt;cfg-&gt;must_match_tagged || \
<span class="lineNum">     356 </span>            :      group-&gt;main-&gt;session-&gt;cfg-&gt;keep_all_untagged)
<span class="lineNum">     357 </span>            : #define NEEDS_NPREF(group)                             \
<span class="lineNum">     358 </span>            :     (group-&gt;main-&gt;session-&gt;cfg-&gt;must_match_untagged || \
<span class="lineNum">     359 </span>            :      group-&gt;main-&gt;session-&gt;cfg-&gt;keep_all_tagged)
<span class="lineNum">     360 </span>            : #define NEEDS_NEW(group) (group-&gt;main-&gt;session-&gt;cfg-&gt;min_mtime)
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : #define HAS_CACHE(session) \
<span class="lineNum">     363 </span>            :     (session-&gt;cfg-&gt;read_cksum_from_xattr || session-&gt;cache_list.length)
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : typedef struct RmShredGroup {
<span class="lineNum">     366 </span>            :     /* holding queue for files; they are held here until the group first meets
<span class="lineNum">     367 </span>            :      * criteria for further hashing (normally just 2 or more files, but sometimes
<span class="lineNum">     368 </span>            :      * related to preferred path counts)
<span class="lineNum">     369 </span>            :      * */
<span class="lineNum">     370 </span>            :     GQueue *held_files;
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     /* link(s) to next generation of RmShredGroups(s) which have this RmShredGroup as
<span class="lineNum">     373 </span>            :      * parent*/
<span class="lineNum">     374 </span>            :     GHashTable *children;
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :     /* RmShredGroup of the same size files but with lower RmFile-&gt;hash_offset;
<span class="lineNum">     377 </span>            :      * getsset to null when parent dies
<span class="lineNum">     378 </span>            :      * */
<span class="lineNum">     379 </span>            :     struct RmShredGroup *parent;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     /* reference count (reasons for keeping group alive):
<span class="lineNum">     382 </span>            :      *   1 for the parent
<span class="lineNum">     383 </span>            :      *   1 for each file that hasn't moved into a child group yet (which it can't do until
<span class="lineNum">     384 </span>            :      * it has hashed the next increment) */
<span class="lineNum">     385 </span>            :     gulong ref_count;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     /* number of files */
<span class="lineNum">     388 </span>            :     gulong num_files;
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :     /* set if group has 1 or more files from &quot;preferred&quot; paths */
<span class="lineNum">     391 </span>            :     bool has_pref;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :     /* set if group has 1 or more files from &quot;non-preferred&quot; paths */
<span class="lineNum">     394 </span>            :     bool has_npref;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :     /* set if group has 1 or more files newer than cfg-&gt;min_mtime */
<span class="lineNum">     397 </span>            :     bool has_new;
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     /* set if group has been greenlighted by paranoid mem manager */
<span class="lineNum">     400 </span>            :     bool is_active;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     /* incremented for each file in the group that obtained it's checksum from ext.
<span class="lineNum">     403 </span>            :      * If all files came from there we do not even need to hash the group.
<span class="lineNum">     404 </span>            :      */
<span class="lineNum">     405 </span>            :     gulong num_ext_cksums;
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :     /* true if all files in the group have an external checksum */
<span class="lineNum">     408 </span>            :     bool has_only_ext_cksums;
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :     /* initially RM_SHRED_GROUP_DORMANT; triggered as soon as we have &gt;= 2 files
<span class="lineNum">     411 </span>            :      * and meet preferred path and will go to either RM_SHRED_GROUP_HASHING or
<span class="lineNum">     412 </span>            :      * RM_SHRED_GROUP_FINISHING.  When switching from dormant to hashing, all
<span class="lineNum">     413 </span>            :      * held_files are released and future arrivals go straight to hashing
<span class="lineNum">     414 </span>            :      * */
<span class="lineNum">     415 </span>            :     RmShredGroupStatus status;
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :     /* file size of files in this group */
<span class="lineNum">     418 </span>            :     RmOff file_size;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :     /* file hash_offset when files arrived in this group */
<span class="lineNum">     421 </span>            :     RmOff hash_offset;
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :     /* file hash_offset for next increment */
<span class="lineNum">     424 </span>            :     RmOff next_offset;
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :     /* Factor of SHRED_BALANCED_PAGES to read next time */
<span class="lineNum">     427 </span>            :     unsigned offset_factor;
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :     /* allocated memory for paranoid hashing */
<span class="lineNum">     430 </span>            :     RmOff mem_allocation;
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :     /* checksum structure taken from first file to enter the group.  This allows
<span class="lineNum">     433 </span>            :      * digests to be released from RmFiles and memory freed up until they
<span class="lineNum">     434 </span>            :      * are required again for further hashing.*/
<span class="lineNum">     435 </span>            :     RmDigestType digest_type;
<span class="lineNum">     436 </span>            :     RmDigest *digest;
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     /* lock for access to this RmShredGroup */
<span class="lineNum">     439 </span>            :     GMutex lock;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :     /* Reference to main */
<span class="lineNum">     442 </span>            :     RmShredTag *main;
<span class="lineNum">     443 </span>            : } RmShredGroup;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : /////////////////////////
<span class="lineNum">     446 </span>            : // PROTOTYPE FUNCTIONS //
<span class="lineNum">     447 </span>            : /////////////////////////
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : /* Prototypes for functions that reference each other */
<span class="lineNum">     450 </span>            : static gboolean rm_shred_sift(RmFile *file);
<span class="lineNum">     451 </span>            : static void rm_shred_push_queue_sorted(RmFile *file);
<span class="lineNum">     452 </span>            : static void rm_shred_group_make_orphan(RmShredGroup *self);
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : /////////// RmShredGroup ////////////////
<span class="lineNum">     455 </span>            : 
<a name="456"><span class="lineNum">     456 </span>            : /* allocate and initialise new RmShredGroup</a>
<span class="lineNum">     457 </span>            :  */
<span class="lineNum">     458 </span><span class="lineCov">      65540 : static RmShredGroup *rm_shred_group_new(RmFile *file) {</span>
<span class="lineNum">     459 </span><span class="lineCov">      65540 :     RmShredGroup *self = g_slice_new0(RmShredGroup);</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineCov">      65539 :     if(file-&gt;digest) {</span>
<span class="lineNum">     462 </span><span class="lineCov">      39498 :         self-&gt;digest = rm_digest_copy(file-&gt;digest);</span>
<span class="lineNum">     463 </span><span class="lineCov">      39499 :         self-&gt;digest_type = file-&gt;digest-&gt;type;</span>
<span class="lineNum">     464 </span>            :     } else {
<span class="lineNum">     465 </span>            :         /* initial groups have no checksum */
<span class="lineNum">     466 </span><span class="lineCov">      26041 :         g_assert(!file-&gt;shred_group);</span>
<span class="lineNum">     467 </span>            :     }
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineCov">      65540 :     self-&gt;parent = file-&gt;shred_group;</span>
<span class="lineNum">     470 </span><span class="lineCov">      65540 :     self-&gt;main = file-&gt;device-&gt;main;</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">      65540 :     if(self-&gt;parent) {</span>
<span class="lineNum">     473 </span><span class="lineCov">      39498 :         self-&gt;ref_count++;</span>
<span class="lineNum">     474 </span><span class="lineCov">      39498 :         if(self-&gt;parent-&gt;offset_factor * 8 &lt;= SHRED_MAX_READ_FACTOR) {</span>
<span class="lineNum">     475 </span><span class="lineCov">      39502 :             self-&gt;offset_factor = self-&gt;parent-&gt;offset_factor * 8;</span>
<span class="lineNum">     476 </span>            :         } else {
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             self-&gt;offset_factor = SHRED_MAX_READ_FACTOR;</span>
<span class="lineNum">     478 </span>            :         }
<span class="lineNum">     479 </span>            :     } else {
<span class="lineNum">     480 </span><span class="lineCov">      26042 :         self-&gt;offset_factor = 1;</span>
<span class="lineNum">     481 </span>            :     }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">      65544 :     self-&gt;held_files = g_queue_new();</span>
<span class="lineNum">     484 </span><span class="lineCov">      65540 :     self-&gt;file_size = file-&gt;file_size;</span>
<span class="lineNum">     485 </span><span class="lineCov">      65540 :     self-&gt;hash_offset = file-&gt;hash_offset;</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineCov">      65540 :     g_assert(file-&gt;device-&gt;main);</span>
<span class="lineNum">     488 </span><span class="lineCov">      65540 :     self-&gt;main = file-&gt;device-&gt;main;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">      65540 :     g_mutex_init(&amp;self-&gt;lock);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">      65540 :     return self;</span>
<span class="lineNum">     493 </span>            : }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : ///////////////////////////////////////
<span class="lineNum">     496 </span>            : //    BUFFER POOL IMPLEMENTATION     //
<a name="497"><span class="lineNum">     497 </span>            : ///////////////////////////////////////</a>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineCov">      65075 : static RmOff rm_buffer_pool_size(RmBufferPool *pool) {</span>
<span class="lineNum">     500 </span><span class="lineCov">      65075 :     return pool-&gt;size;</span>
<a name="501"><span class="lineNum">     501 </span>            : }</a>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineCov">      13188 : static RmBufferPool *rm_buffer_pool_init(gsize size) {</span>
<span class="lineNum">     504 </span><span class="lineCov">      13188 :     RmBufferPool *self = g_slice_new(RmBufferPool);</span>
<span class="lineNum">     505 </span><span class="lineCov">      13188 :     self-&gt;stack = NULL;</span>
<span class="lineNum">     506 </span><span class="lineCov">      13188 :     self-&gt;size = size;</span>
<span class="lineNum">     507 </span><span class="lineCov">      13188 :     g_mutex_init(&amp;self-&gt;lock);</span>
<span class="lineNum">     508 </span><span class="lineCov">      13188 :     return self;</span>
<a name="509"><span class="lineNum">     509 </span>            : }</a>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">      13188 : static void rm_buffer_pool_destroy(RmBufferPool *pool) {</span>
<span class="lineNum">     512 </span><span class="lineCov">      13188 :     g_mutex_lock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     513 </span>            :     {
<span class="lineNum">     514 </span><span class="lineCov">      74257 :         while(pool-&gt;stack != NULL) {</span>
<span class="lineNum">     515 </span><span class="lineCov">      47881 :             g_slice_free1(pool-&gt;size, g_trash_stack_pop(&amp;pool-&gt;stack));</span>
<span class="lineNum">     516 </span>            :         }
<span class="lineNum">     517 </span>            :     }
<span class="lineNum">     518 </span><span class="lineCov">      13188 :     g_mutex_unlock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     519 </span><span class="lineCov">      13188 :     g_mutex_clear(&amp;pool-&gt;lock);</span>
<span class="lineNum">     520 </span><span class="lineCov">      13188 :     g_slice_free(RmBufferPool, pool);</span>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">      13188 : }</span></a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">     200164 : static void *rm_buffer_pool_get(RmBufferPool *pool) {</span>
<span class="lineNum">     524 </span><span class="lineCov">     200164 :     void *buffer = NULL;</span>
<span class="lineNum">     525 </span><span class="lineCov">     200164 :     g_mutex_lock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     526 </span>            :     {
<span class="lineNum">     527 </span><span class="lineCov">     200164 :         if(!pool-&gt;stack) {</span>
<span class="lineNum">     528 </span><span class="lineCov">      47881 :             buffer = g_slice_alloc(pool-&gt;size);</span>
<span class="lineNum">     529 </span>            :         } else {
<span class="lineNum">     530 </span><span class="lineCov">     152283 :             buffer = g_trash_stack_pop(&amp;pool-&gt;stack);</span>
<span class="lineNum">     531 </span>            :         }
<span class="lineNum">     532 </span>            :     }
<span class="lineNum">     533 </span><span class="lineCov">     200164 :     g_mutex_unlock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     534 </span><span class="lineCov">     200164 :     g_assert(buffer);</span>
<span class="lineNum">     535 </span><span class="lineCov">     200164 :     return buffer;</span>
<a name="536"><span class="lineNum">     536 </span>            : }</a>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">     199878 : static void rm_buffer_pool_release(RmBufferPool *pool, void *buf) {</span>
<span class="lineNum">     539 </span><span class="lineCov">     199878 :     g_mutex_lock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     540 </span><span class="lineCov">     200164 :     { g_trash_stack_push(&amp;pool-&gt;stack, buf); }</span>
<span class="lineNum">     541 </span><span class="lineCov">     200164 :     g_mutex_unlock(&amp;pool-&gt;lock);</span>
<span class="lineNum">     542 </span><span class="lineCov">     200119 : }</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : //////////////////////////////////
<span class="lineNum">     545 </span>            : // OPTIMISATION AND MEMORY      //
<span class="lineNum">     546 </span>            : // MANAGEMENT ALGORITHMS        //
<span class="lineNum">     547 </span>            : //////////////////////////////////
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : /* Compute optimal size for next hash increment
<a name="550"><span class="lineNum">     550 </span>            :  * call this with group locked</a>
<span class="lineNum">     551 </span>            :  * */
<span class="lineNum">     552 </span><span class="lineCov">      72095 : static gint32 rm_shred_get_read_size(RmFile *file, RmShredTag *tag) {</span>
<span class="lineNum">     553 </span><span class="lineCov">      72095 :     RmShredGroup *group = file-&gt;shred_group;</span>
<span class="lineNum">     554 </span><span class="lineCov">      72095 :     g_assert(group);</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineCov">      72095 :     gint32 result = 0;</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :     /* calculate next_offset property of the RmShredGroup */
<span class="lineNum">     559 </span><span class="lineCov">      72095 :     RmOff balanced_bytes = tag-&gt;page_size * SHRED_BALANCED_PAGES;</span>
<span class="lineNum">     560 </span><span class="lineCov">      72095 :     RmOff target_bytes = balanced_bytes * group-&gt;offset_factor;</span>
<span class="lineNum">     561 </span><span class="lineCov">      72095 :     if(group-&gt;next_offset == 2) {</span>
<span class="lineNum">     562 </span><span class="lineCov">        271 :         file-&gt;fadvise_requested = 1;</span>
<span class="lineNum">     563 </span>            :     }
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :     /* round to even number of pages, round up to MIN_READ_PAGES */
<span class="lineNum">     566 </span><span class="lineCov">      72095 :     RmOff target_pages = MAX(target_bytes / tag-&gt;page_size, 1);</span>
<span class="lineNum">     567 </span><span class="lineCov">      72095 :     target_bytes = target_pages * tag-&gt;page_size;</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     /* test if cost-effective to read the whole file */
<span class="lineNum">     570 </span><span class="lineCov">      72095 :     if(group-&gt;hash_offset + target_bytes + balanced_bytes &gt;= group-&gt;file_size) {</span>
<span class="lineNum">     571 </span><span class="lineCov">      71921 :         group-&gt;next_offset = group-&gt;file_size;</span>
<span class="lineNum">     572 </span>            :     } else {
<span class="lineNum">     573 </span><span class="lineCov">        174 :         group-&gt;next_offset = group-&gt;hash_offset + target_bytes;</span>
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :     /* for paranoid digests, make sure next read is not &gt; max size of paranoid buffer */
<span class="lineNum">     577 </span><span class="lineCov">      72095 :     if(group-&gt;digest_type == RM_DIGEST_PARANOID) {</span>
<span class="lineNum">     578 </span><span class="lineCov">      22234 :         group-&gt;next_offset =</span>
<span class="lineNum">     579 </span><span class="lineCov">      22234 :             MIN(group-&gt;next_offset, group-&gt;hash_offset + rm_digest_paranoia_bytes());</span>
<span class="lineNum">     580 </span>            :     }
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">      72095 :     file-&gt;status = RM_FILE_STATE_NORMAL;</span>
<span class="lineNum">     583 </span><span class="lineCov">      72095 :     result = (group-&gt;next_offset - file-&gt;seek_offset);</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineCov">      72095 :     return result;</span>
<span class="lineNum">     586 </span>            : }
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : /* Memory manager (only used for RM_DIGEST_PARANOID at the moment
<span class="lineNum">     589 </span>            :  * but could also be adapted for other digests if very large
<span class="lineNum">     590 </span>            :  * filesystems are contemplated)
<a name="591"><span class="lineNum">     591 </span>            :  */</a>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">      81368 : static void rm_shred_mem_return(RmShredGroup *group) {</span>
<span class="lineNum">     594 </span><span class="lineCov">      81368 :     if(group-&gt;is_active) {</span>
<span class="lineNum">     595 </span><span class="lineCov">       3441 :         RmShredTag *tag = group-&gt;main;</span>
<span class="lineNum">     596 </span><span class="lineCov">       3441 :         g_mutex_lock(&amp;tag-&gt;hash_mem_mtx);</span>
<span class="lineNum">     597 </span>            :         {
<span class="lineNum">     598 </span><span class="lineCov">       3443 :             tag-&gt;hash_mem_alloc += group-&gt;mem_allocation;</span>
<span class="lineNum">     599 </span><span class="lineCov">       3443 :             tag-&gt;active_groups--;</span>
<span class="lineNum">     600 </span><span class="lineCov">       3443 :             group-&gt;is_active = FALSE;</span>
<span class="lineNum">     601 </span><span class="lineCov">       3443 :             rm_log_debug(&quot;Mem avail %li, active groups %d. &quot; YELLOW &quot;Returned %&quot; LLU</span>
<span class="lineNum">     602 </span>            :                          &quot; bytes for paranoid hashing.\n&quot; RESET,
<span class="lineNum">     603 </span>            :                          tag-&gt;hash_mem_alloc, tag-&gt;active_groups, group-&gt;mem_allocation);
<span class="lineNum">     604 </span><span class="lineCov">       3443 :             tag-&gt;mem_refusing = FALSE;</span>
<span class="lineNum">     605 </span><span class="lineCov">       3443 :             if(group-&gt;digest) {</span>
<span class="lineNum">     606 </span><span class="lineCov">         24 :                 g_assert(group-&gt;digest-&gt;type == RM_DIGEST_PARANOID);</span>
<span class="lineNum">     607 </span><span class="lineCov">         24 :                 rm_digest_free(group-&gt;digest);</span>
<span class="lineNum">     608 </span><span class="lineCov">         24 :                 group-&gt;digest = NULL;</span>
<span class="lineNum">     609 </span>            :             }
<span class="lineNum">     610 </span>            :         }
<span class="lineNum">     611 </span><span class="lineCov">       3443 :         g_mutex_unlock(&amp;tag-&gt;hash_mem_mtx);</span>
<span class="lineNum">     612 </span><span class="lineCov">       3443 :         group-&gt;mem_allocation = 0;</span>
<span class="lineNum">     613 </span>            :     }
<span class="lineNum">     614 </span><span class="lineCov">      81370 : }</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            : /* what is the maximum number of files that a group may end up with (including
<a name="617"><span class="lineNum">     617 </span>            :  * parent, grandparent etc group files that haven't been hashed yet)?</a>
<span class="lineNum">     618 </span>            :  */
<span class="lineNum">     619 </span><span class="lineCov">       5812 : static gulong rm_shred_group_potential_file_count(RmShredGroup *group) {</span>
<span class="lineNum">     620 </span><span class="lineCov">       5812 :     if(group-&gt;parent) {</span>
<span class="lineNum">     621 </span><span class="lineCov">         28 :         return group-&gt;ref_count + rm_shred_group_potential_file_count(group-&gt;parent) - 1;</span>
<span class="lineNum">     622 </span>            :     } else {
<span class="lineNum">     623 </span><span class="lineCov">       5784 :         return group-&gt;ref_count;</span>
<span class="lineNum">     624 </span>            :     }
<span class="lineNum">     625 </span>            : }
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : /* Governer to limit memory usage by limiting how many RmShredGroups can be
<span class="lineNum">     628 </span>            :  * active at any one time
<a name="629"><span class="lineNum">     629 </span>            :  * NOTE: group_lock must be held before calling rm_shred_check_hash_mem_alloc</a>
<span class="lineNum">     630 </span>            :  */
<span class="lineNum">     631 </span><span class="lineCov">      23576 : static bool rm_shred_check_hash_mem_alloc(RmShredGroup *group,</span>
<span class="lineNum">     632 </span>            :                                           int active_group_threshold) {
<span class="lineNum">     633 </span><span class="lineCov">      23576 :     if(group-&gt;status &gt;= RM_SHRED_GROUP_HASHING) {</span>
<span class="lineNum">     634 </span>            :         /* group already committed */
<span class="lineNum">     635 </span><span class="lineCov">      17792 :         return true;</span>
<span class="lineNum">     636 </span>            :     }
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span><span class="lineCov">       5784 :     gint64 mem_required =</span>
<span class="lineNum">     639 </span><span class="lineCov">      11568 :         rm_shred_group_potential_file_count(group) *</span>
<span class="lineNum">     640 </span><span class="lineCov">       5784 :         MIN(group-&gt;file_size - group-&gt;hash_offset, 2 * rm_digest_paranoia_bytes());</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineCov">       5784 :     bool result = FALSE;</span>
<span class="lineNum">     643 </span><span class="lineCov">       5784 :     RmShredTag *tag = group-&gt;main;</span>
<span class="lineNum">     644 </span><span class="lineCov">       5784 :     g_mutex_lock(&amp;tag-&gt;hash_mem_mtx);</span>
<span class="lineNum">     645 </span>            :     {
<span class="lineNum">     646 </span><span class="lineCov">       5784 :         gint64 inherited = group-&gt;parent ? group-&gt;parent-&gt;mem_allocation : 0;</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineCov">       8131 :         if(0 || mem_required &lt;= tag-&gt;hash_mem_alloc + inherited ||</span>
<span class="lineNum">     649 </span><span class="lineCov">       5790 :            (tag-&gt;active_groups &lt;= active_group_threshold)) {</span>
<span class="lineNum">     650 </span>            :             /* ok to proceed */
<span class="lineNum">     651 </span>            :             /* only take what we need from parent */
<span class="lineNum">     652 </span><span class="lineCov">       3443 :             inherited = MIN(inherited, mem_required);</span>
<span class="lineNum">     653 </span><span class="lineCov">       3443 :             if(inherited &gt; 0) {</span>
<span class="lineNum">     654 </span><span class="lineCov">         22 :                 group-&gt;parent-&gt;mem_allocation -= inherited;</span>
<span class="lineNum">     655 </span><span class="lineCov">         22 :                 group-&gt;mem_allocation += inherited;</span>
<span class="lineNum">     656 </span>            :             }
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            :             /* take the rest from bank */
<span class="lineNum">     659 </span><span class="lineCov">       3443 :             gint64 borrowed = MIN(mem_required - inherited, (gint64)tag-&gt;hash_mem_alloc);</span>
<span class="lineNum">     660 </span><span class="lineCov">       3443 :             tag-&gt;hash_mem_alloc -= borrowed;</span>
<span class="lineNum">     661 </span><span class="lineCov">       3443 :             group-&gt;mem_allocation += borrowed;</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineCov">       3443 :             rm_log_debug(&quot;Mem avail %li, active groups %d.&quot; GREEN &quot; Borrowed %li&quot;,</span>
<span class="lineNum">     664 </span>            :                          tag-&gt;hash_mem_alloc, tag-&gt;active_groups, borrowed);
<span class="lineNum">     665 </span><span class="lineCov">       3443 :             if(inherited &gt; 0) {</span>
<span class="lineNum">     666 </span><span class="lineCov">         22 :                 rm_log_debug(&quot;and inherited %li&quot;, inherited);</span>
<span class="lineNum">     667 </span>            :             }
<span class="lineNum">     668 </span><span class="lineCov">       3443 :             rm_log_debug(&quot; bytes for paranoid hashing&quot;);</span>
<span class="lineNum">     669 </span><span class="lineCov">       3443 :             if(mem_required &gt; borrowed + inherited) {</span>
<span class="lineNum">     670 </span><span class="lineCov">          6 :                 rm_log_debug(&quot; due to %i active group limit&quot;, active_group_threshold);</span>
<span class="lineNum">     671 </span>            :             }
<span class="lineNum">     672 </span><span class="lineCov">       3443 :             rm_log_debug(&quot;\n&quot; RESET);</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineCov">       3443 :             tag-&gt;active_groups++;</span>
<span class="lineNum">     675 </span><span class="lineCov">       3443 :             group-&gt;is_active = TRUE;</span>
<span class="lineNum">     676 </span><span class="lineCov">       3443 :             tag-&gt;mem_refusing = FALSE;</span>
<span class="lineNum">     677 </span><span class="lineCov">       3443 :             group-&gt;status = RM_SHRED_GROUP_HASHING;</span>
<span class="lineNum">     678 </span><span class="lineCov">       3443 :             result = TRUE;</span>
<span class="lineNum">     679 </span>            :         } else {
<span class="lineNum">     680 </span><span class="lineCov">       2341 :             if(!tag-&gt;mem_refusing) {</span>
<span class="lineNum">     681 </span><span class="lineCov">        236 :                 rm_log_debug(&quot;Mem avail %li, active groups %d. &quot; RED</span>
<span class="lineNum">     682 </span>            :                              &quot;Refused request for %&quot; LLU
<span class="lineNum">     683 </span>            :                              &quot; bytes for paranoid hashing.\n&quot; RESET,
<span class="lineNum">     684 </span>            :                              tag-&gt;hash_mem_alloc, tag-&gt;active_groups, mem_required);
<span class="lineNum">     685 </span><span class="lineCov">        236 :                 tag-&gt;mem_refusing = TRUE;</span>
<span class="lineNum">     686 </span>            :             }
<span class="lineNum">     687 </span><span class="lineCov">       2341 :             result = FALSE;</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span>            :     }
<span class="lineNum">     690 </span><span class="lineCov">       5784 :     g_mutex_unlock(&amp;tag-&gt;hash_mem_mtx);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">       5784 :     return result;</span>
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : ///////////////////////////////////
<span class="lineNum">     696 </span>            : //    RmShredDevice UTILITIES    //
<a name="697"><span class="lineNum">     697 </span>            : ///////////////////////////////////</a>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">     217641 : static void rm_shred_adjust_counters(RmShredDevice *device, int files, gint64 bytes) {</span>
<span class="lineNum">     700 </span><span class="lineCov">     217641 :     g_mutex_lock(&amp;(device-&gt;lock));</span>
<span class="lineNum">     701 </span>            :     {
<span class="lineNum">     702 </span><span class="lineCov">     217761 :         device-&gt;remaining_files += files;</span>
<span class="lineNum">     703 </span><span class="lineCov">     217761 :         device-&gt;remaining_bytes += bytes;</span>
<span class="lineNum">     704 </span>            :     }
<span class="lineNum">     705 </span><span class="lineCov">     217761 :     g_mutex_unlock(&amp;(device-&gt;lock));</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">     217751 :     RmSession *session = device-&gt;main-&gt;session;</span>
<span class="lineNum">     708 </span><span class="lineCov">     217751 :     rm_fmt_lock_state(session-&gt;formats);</span>
<span class="lineNum">     709 </span>            :     {
<span class="lineNum">     710 </span><span class="lineCov">     217761 :         session-&gt;shred_files_remaining += files;</span>
<span class="lineNum">     711 </span><span class="lineCov">     217761 :         if(files &lt; 0) {</span>
<span class="lineNum">     712 </span><span class="lineCov">      75959 :             session-&gt;total_filtered_files += files;</span>
<span class="lineNum">     713 </span>            :         }
<span class="lineNum">     714 </span><span class="lineCov">     217761 :         session-&gt;shred_bytes_remaining += bytes;</span>
<span class="lineNum">     715 </span><span class="lineCov">     217761 :         rm_fmt_set_state(session-&gt;formats, (device-&gt;after_preprocess)</span>
<span class="lineNum">     716 </span>            :                                                ? RM_PROGRESS_STATE_SHREDDER
<span class="lineNum">     717 </span>            :                                                : RM_PROGRESS_STATE_PREPROCESS);
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span><span class="lineCov">     217761 :     rm_fmt_unlock_state(session-&gt;formats);</span>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">     217752 : }</span></a>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineCov">      65329 : static void rm_shred_write_cksum_to_xattr(RmSession *session, RmFile *file) {</span>
<span class="lineNum">     723 </span><span class="lineCov">      65329 :     if(session-&gt;cfg-&gt;write_cksum_to_xattr) {</span>
<span class="lineNum">     724 </span><span class="lineCov">       1218 :         if(file-&gt;has_ext_cksum == false) {</span>
<span class="lineNum">     725 </span><span class="lineCov">       1218 :             rm_xattr_write_hash(session, file);</span>
<span class="lineNum">     726 </span>            :         }
<span class="lineNum">     727 </span>            :     }
<span class="lineNum">     728 </span><span class="lineCov">      65328 : }</span>
<span class="lineNum">     729 </span>            : 
<a name="730"><span class="lineNum">     730 </span>            : /* Hash file. Runs as threadpool in parallel / tandem with rm_shred_read_factory above</a>
<span class="lineNum">     731 </span>            :  * */
<span class="lineNum">     732 </span><span class="lineCov">     134845 : static void rm_shred_hash_factory(RmBuffer *buffer, RmShredTag *tag) {</span>
<span class="lineNum">     733 </span><span class="lineCov">     134845 :     g_assert(tag);</span>
<span class="lineNum">     734 </span><span class="lineCov">     134845 :     g_assert(buffer);</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineCov">     134845 :     if(!buffer-&gt;finished) {</span>
<span class="lineNum">     737 </span>            :         /* Hash buffer-&gt;len bytes_read of buffer-&gt;data into buffer-&gt;file */
<span class="lineNum">     738 </span><span class="lineCov">      69775 :         rm_digest_update(buffer-&gt;file-&gt;digest, buffer-&gt;data, buffer-&gt;len);</span>
<span class="lineNum">     739 </span><span class="lineCov">      69777 :         buffer-&gt;file-&gt;hash_offset += buffer-&gt;len;</span>
<span class="lineNum">     740 </span>            :     } else {
<span class="lineNum">     741 </span>            :         /* Report the progress to rm_shred_devlist_factory */
<span class="lineNum">     742 </span><span class="lineCov">      65070 :         g_assert(buffer-&gt;file-&gt;hash_offset == buffer-&gt;file-&gt;shred_group-&gt;next_offset ||</span>
<span class="lineNum">     743 </span>            :                  buffer-&gt;file-&gt;status == RM_FILE_STATE_FRAGMENT ||
<span class="lineNum">     744 </span>            :                  buffer-&gt;file-&gt;status == RM_FILE_STATE_IGNORE);
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineCov">      65070 :         if(buffer-&gt;file-&gt;status != RM_FILE_STATE_IGNORE) {</span>
<span class="lineNum">     747 </span>            :             /* remember that checksum */
<span class="lineNum">     748 </span><span class="lineCov">      65068 :             rm_shred_write_cksum_to_xattr(tag-&gt;session, buffer-&gt;file);</span>
<span class="lineNum">     749 </span>            :         }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineCov">      65064 :         if(buffer-&gt;file-&gt;devlist_waiting) {</span>
<span class="lineNum">     752 </span>            :             /* devlist factory is waiting for result */
<span class="lineNum">     753 </span><span class="lineCov">       1697 :             g_async_queue_push(buffer-&gt;file-&gt;device-&gt;hashed_file_return, buffer-&gt;file);</span>
<span class="lineNum">     754 </span>            :         } else {
<span class="lineNum">     755 </span>            :             /* handle the file ourselves; devlist factory has moved on to the next file */
<span class="lineNum">     756 </span><span class="lineCov">      63367 :             if(buffer-&gt;file-&gt;status == RM_FILE_STATE_FRAGMENT) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                 rm_shred_push_queue_sorted(buffer-&gt;file);</span>
<span class="lineNum">     758 </span>            :             } else {
<span class="lineNum">     759 </span><span class="lineCov">      63367 :                 rm_shred_sift(buffer-&gt;file);</span>
<span class="lineNum">     760 </span>            :             }
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     /* Return this buffer to the pool */
<span class="lineNum">     765 </span><span class="lineCov">     134835 :     rm_buffer_pool_release(tag-&gt;mem_pool, buffer);</span>
<a name="766"><span class="lineNum">     766 </span><span class="lineCov">     134861 : }</span></a>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineCov">      13050 : static RmShredDevice *rm_shred_device_new(gboolean is_rotational, char *disk_name,</span>
<span class="lineNum">     769 </span>            :                                           RmShredTag *main) {
<span class="lineNum">     770 </span><span class="lineCov">      13050 :     RmShredDevice *self = g_slice_new0(RmShredDevice);</span>
<span class="lineNum">     771 </span><span class="lineCov">      13050 :     self-&gt;main = main;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">      13050 :     if(!rm_session_was_aborted(main-&gt;session)) {</span>
<span class="lineNum">     774 </span><span class="lineCov">      13050 :         g_assert(self-&gt;remaining_files == 0);</span>
<span class="lineNum">     775 </span><span class="lineCov">      13050 :         g_assert(self-&gt;remaining_bytes == 0);</span>
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineCov">      13050 :     self-&gt;is_rotational = is_rotational;</span>
<span class="lineNum">     779 </span><span class="lineCov">      13050 :     self-&gt;disk_name = g_strdup(disk_name);</span>
<span class="lineNum">     780 </span><span class="lineCov">      13050 :     self-&gt;file_queue = g_queue_new();</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">      13050 :     self-&gt;hashed_file_return = g_async_queue_new();</span>
<span class="lineNum">     783 </span><span class="lineCov">      13050 :     self-&gt;page_size = main-&gt;page_size;</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineCov">      13050 :     g_mutex_init(&amp;(self-&gt;lock));</span>
<span class="lineNum">     786 </span><span class="lineCov">      13050 :     g_cond_init(&amp;(self-&gt;change));</span>
<span class="lineNum">     787 </span><span class="lineCov">      13050 :     return self;</span>
<a name="788"><span class="lineNum">     788 </span>            : }</a>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineCov">      13050 : static void rm_shred_device_free(RmShredDevice *self) {</span>
<span class="lineNum">     791 </span><span class="lineCov">      13050 :     if(!rm_session_was_aborted(self-&gt;main-&gt;session)) {</span>
<span class="lineNum">     792 </span><span class="lineCov">      13050 :         g_assert(self-&gt;remaining_files == 0);</span>
<span class="lineNum">     793 </span><span class="lineCov">      13050 :         g_assert(g_queue_is_empty(self-&gt;file_queue));</span>
<span class="lineNum">     794 </span><span class="lineCov">      13050 :         g_assert(g_async_queue_length(self-&gt;hashed_file_return) == 0);</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineCov">      13050 :     g_async_queue_unref(self-&gt;hashed_file_return);</span>
<span class="lineNum">     798 </span><span class="lineCov">      13050 :     g_queue_free(self-&gt;file_queue);</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineCov">      13050 :     g_free(self-&gt;disk_name);</span>
<span class="lineNum">     801 </span><span class="lineCov">      13050 :     g_cond_clear(&amp;(self-&gt;change));</span>
<span class="lineNum">     802 </span><span class="lineCov">      13050 :     g_mutex_clear(&amp;(self-&gt;lock));</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">      13050 :     g_slice_free(RmShredDevice, self);</span>
<span class="lineNum">     805 </span><span class="lineCov">      13050 : }</span>
<span class="lineNum">     806 </span>            : 
<a name="807"><span class="lineNum">     807 </span>            : /* Unlink RmFile from device queue</a>
<span class="lineNum">     808 </span>            :  */
<span class="lineNum">     809 </span><span class="lineCov">      76736 : static void rm_shred_discard_file(RmFile *file, bool free_file) {</span>
<span class="lineNum">     810 </span><span class="lineCov">      76736 :     RmShredDevice *device = file-&gt;device;</span>
<span class="lineNum">     811 </span>            :     /* update device counters */
<span class="lineNum">     812 </span><span class="lineCov">      76736 :     if(device) {</span>
<span class="lineNum">     813 </span><span class="lineCov">      75920 :         RmSession *session = device-&gt;main-&gt;session;</span>
<span class="lineNum">     814 </span><span class="lineCov">      75920 :         rm_shred_adjust_counters(device, -1,</span>
<span class="lineNum">     815 </span><span class="lineCov">      75920 :                                  -(gint64)(file-&gt;file_size - file-&gt;hash_offset));</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :         /* ShredGroup that was going nowhere */
<span class="lineNum">     818 </span><span class="lineCov">      75951 :         if(file-&gt;shred_group-&gt;num_files &lt;= 1 &amp;&amp; session-&gt;cfg-&gt;write_unfinished) {</span>
<span class="lineNum">     819 </span><span class="lineCov">        522 :             RmLintType actual_type = file-&gt;lint_type;</span>
<span class="lineNum">     820 </span><span class="lineCov">        522 :             file-&gt;lint_type = RM_LINT_TYPE_UNFINISHED_CKSUM;</span>
<span class="lineNum">     821 </span><span class="lineCov">        522 :             file-&gt;digest = (file-&gt;digest) ? file-&gt;digest : file-&gt;shred_group-&gt;digest;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">        522 :             if(file-&gt;digest) {</span>
<span class="lineNum">     824 </span><span class="lineCov">        261 :                 rm_fmt_write(file, session-&gt;formats);</span>
<span class="lineNum">     825 </span><span class="lineCov">        261 :                 rm_shred_write_cksum_to_xattr(session, file);</span>
<span class="lineNum">     826 </span><span class="lineCov">        261 :                 file-&gt;digest = NULL;</span>
<span class="lineNum">     827 </span>            :             }
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineCov">        522 :             file-&gt;lint_type = actual_type;</span>
<span class="lineNum">     830 </span>            :         }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :         /* update paranoid memory allocator */
<span class="lineNum">     833 </span><span class="lineCov">      75951 :         if(file-&gt;shred_group-&gt;digest_type == RM_DIGEST_PARANOID) {</span>
<span class="lineNum">     834 </span><span class="lineCov">      24720 :             g_assert(file);</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineCov">      24720 :             RmShredTag *tag = file-&gt;shred_group-&gt;main;</span>
<span class="lineNum">     837 </span><span class="lineCov">      24720 :             g_assert(tag);</span>
<span class="lineNum">     838 </span>            :         }
<span class="lineNum">     839 </span>            :     }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">      76767 :     if(free_file) {</span>
<span class="lineNum">     842 </span>            :         /* toss the file (and any embedded hardlinks)*/
<span class="lineNum">     843 </span><span class="lineCov">      34715 :         rm_file_destroy(file);</span>
<span class="lineNum">     844 </span>            :     }
<span class="lineNum">     845 </span><span class="lineCov">      76767 : }</span>
<span class="lineNum">     846 </span>            : 
<a name="847"><span class="lineNum">     847 </span>            : /* GCompareFunc for sorting files into optimum read order</a>
<span class="lineNum">     848 </span>            :  * */
<span class="lineNum">     849 </span><span class="lineCov">     264582 : static int rm_shred_compare_file_order(const RmFile *a, const RmFile *b,</span>
<span class="lineNum">     850 </span>            :                                        _U gpointer user_data) {
<span class="lineNum">     851 </span>            :     /* compare based on partition (dev), then offset, then inode offset is a
<span class="lineNum">     852 </span>            :      * RmOff, so do not substract them (will cause over or underflows on
<span class="lineNum">     853 </span>            :      * regular basis) - use SIGN_DIFF instead
<span class="lineNum">     854 </span>            :      */
<span class="lineNum">     855 </span><span class="lineCov">     264582 :     RmOff phys_offset_a = a-&gt;current_disk_offset;</span>
<span class="lineNum">     856 </span><span class="lineCov">     264582 :     RmOff phys_offset_b = b-&gt;current_disk_offset;</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineCov">     529164 :     return (4 * SIGN_DIFF(a-&gt;dev, b-&gt;dev) + 2 * SIGN_DIFF(phys_offset_a, phys_offset_b) +</span>
<span class="lineNum">     859 </span><span class="lineCov">     264582 :             1 * SIGN_DIFF(a-&gt;inode, b-&gt;inode));</span>
<span class="lineNum">     860 </span>            : }
<span class="lineNum">     861 </span>            : 
<a name="862"><span class="lineNum">     862 </span>            : /* Populate disk_offsets table for each file, if disk is rotational</a>
<span class="lineNum">     863 </span>            :  * */
<span class="lineNum">     864 </span><span class="lineCov">      65759 : static void rm_shred_file_get_offset_table(RmFile *file, RmSession *session) {</span>
<span class="lineNum">     865 </span><span class="lineCov">      65759 :     if(file-&gt;device-&gt;is_rotational &amp;&amp; session-&gt;cfg-&gt;build_fiemap) {</span>
<span class="lineNum">     866 </span><span class="lineCov">       3622 :         g_assert(!file-&gt;disk_offsets);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">       3622 :         RM_DEFINE_PATH(file);</span>
<span class="lineNum">     869 </span><span class="lineCov">       3622 :         file-&gt;disk_offsets = rm_offset_create_table(file_path, session-&gt;cfg-&gt;fake_fiemap);</span>
<span class="lineNum">     870 </span><span class="lineCov">       3622 :         rm_fmt_set_state(session-&gt;formats, RM_PROGRESS_STATE_PREPROCESS);</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineCov">       3622 :         session-&gt;offsets_read++;</span>
<span class="lineNum">     873 </span><span class="lineCov">       3622 :         if(file-&gt;disk_offsets) {</span>
<span class="lineNum">     874 </span><span class="lineCov">       3622 :             session-&gt;offset_fragments +=</span>
<span class="lineNum">     875 </span><span class="lineCov">       3622 :                 g_sequence_get_length((GSequence *)file-&gt;disk_offsets);</span>
<span class="lineNum">     876 </span>            :         } else {
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :             session-&gt;offset_fails++;</span>
<span class="lineNum">     878 </span>            :         }
<span class="lineNum">     879 </span>            :     }
<span class="lineNum">     880 </span><span class="lineCov">      65759 : }</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : /* Push file to device queue (sorted and unsorted variants)
<span class="lineNum">     883 </span>            :  * Initial list build is unsorted to avoid slowing down;
<span class="lineNum">     884 </span>            :  * List re-inserts during Shredding are sorted so that
<a name="885"><span class="lineNum">     885 </span>            :  * some seeks can be avoided</a>
<span class="lineNum">     886 </span>            :  * */
<span class="lineNum">     887 </span><span class="lineCov">      65843 : static void rm_shred_push_queue_sorted_impl(RmFile *file, bool sorted) {</span>
<span class="lineNum">     888 </span><span class="lineCov">      65843 :     RmShredDevice *device = file-&gt;device;</span>
<span class="lineNum">     889 </span><span class="lineCov">      65843 :     g_assert(!file-&gt;digest || file-&gt;status == RM_FILE_STATE_FRAGMENT);</span>
<span class="lineNum">     890 </span><span class="lineCov">      65843 :     g_mutex_lock(&amp;device-&gt;lock);</span>
<span class="lineNum">     891 </span>            :     {
<span class="lineNum">     892 </span><span class="lineCov">      65843 :         if(sorted) {</span>
<span class="lineNum">     893 </span><span class="lineCov">         32 :             g_queue_insert_sorted(device-&gt;file_queue, file,</span>
<span class="lineNum">     894 </span>            :                                   (GCompareDataFunc)rm_shred_compare_file_order, NULL);
<span class="lineNum">     895 </span>            :         } else {
<span class="lineNum">     896 </span><span class="lineCov">      65811 :             g_queue_push_head(device-&gt;file_queue, file);</span>
<span class="lineNum">     897 </span>            :         }
<span class="lineNum">     898 </span><span class="lineCov">      65843 :         g_cond_signal(&amp;device-&gt;change);</span>
<span class="lineNum">     899 </span>            :     }
<span class="lineNum">     900 </span><span class="lineCov">      65843 :     g_mutex_unlock(&amp;device-&gt;lock);</span>
<a name="901"><span class="lineNum">     901 </span><span class="lineCov">      65843 : }</span></a>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineCov">      65811 : static void rm_shred_push_queue(RmFile *file) {</span>
<span class="lineNum">     904 </span><span class="lineCov">      65811 :     rm_shred_push_queue_sorted_impl(file, false);</span>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">      65811 : }</span></a>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">         32 : static void rm_shred_push_queue_sorted(RmFile *file) {</span>
<span class="lineNum">     908 </span><span class="lineCov">         32 :     rm_shred_push_queue_sorted_impl(file, true);</span>
<span class="lineNum">     909 </span><span class="lineCov">         32 : }</span>
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : //////////////////////////////////
<span class="lineNum">     912 </span>            : //    RMSHREDGROUP UTILITIES    //
<span class="lineNum">     913 </span>            : //    AND SIFTING ALGORITHM     //
<span class="lineNum">     914 </span>            : //////////////////////////////////
<span class="lineNum">     915 </span>            : 
<a name="916"><span class="lineNum">     916 </span>            : /* Free RmShredGroup and any dormant files still in its queue</a>
<span class="lineNum">     917 </span>            :  */
<span class="lineNum">     918 </span><span class="lineCov">      65508 : static void rm_shred_group_free(RmShredGroup *self) {</span>
<span class="lineNum">     919 </span><span class="lineCov">      65508 :     g_assert(self-&gt;parent == NULL); /* children should outlive their parents! */</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :     /* For -D we need to hold back the memory a bit longer */
<span class="lineNum">     922 </span><span class="lineCov">      65508 :     bool needs_free = !(self-&gt;main-&gt;session-&gt;cfg-&gt;merge_directories);</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineCov">      65508 :     if(self-&gt;held_files) {</span>
<span class="lineNum">     925 </span><span class="lineCov">      49630 :         g_queue_foreach(self-&gt;held_files, (GFunc)rm_shred_discard_file,</span>
<span class="lineNum">     926 </span><span class="lineCov">      49630 :                         GUINT_TO_POINTER(needs_free));</span>
<span class="lineNum">     927 </span><span class="lineCov">      49651 :         g_queue_free(self-&gt;held_files);</span>
<span class="lineNum">     928 </span><span class="lineCov">      49646 :         self-&gt;held_files = NULL;</span>
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">      65524 :     rm_shred_mem_return(self);</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineCov">      65509 :     if(self-&gt;digest &amp;&amp; needs_free) {</span>
<span class="lineNum">     934 </span><span class="lineCov">      16352 :         rm_digest_free(self-&gt;digest);</span>
<span class="lineNum">     935 </span><span class="lineCov">      16352 :         self-&gt;digest = NULL;</span>
<span class="lineNum">     936 </span>            :     }
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineCov">      65509 :     if(self-&gt;children) {</span>
<span class="lineNum">     939 </span><span class="lineCov">      15885 :         g_hash_table_unref(self-&gt;children);</span>
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineCov">      65510 :     g_mutex_clear(&amp;self-&gt;lock);</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineCov">      65506 :     g_slice_free(RmShredGroup, self);</span>
<span class="lineNum">     945 </span><span class="lineCov">      65523 : }</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            : /* Checks whether group qualifies as duplicate candidate (ie more than
<span class="lineNum">     948 </span>            :  * two members and meets has_pref and NEEDS_PREF criteria).
<a name="949"><span class="lineNum">     949 </span>            :  * Assume group already protected by group_lock.</a>
<span class="lineNum">     950 </span>            :  * */
<span class="lineNum">     951 </span><span class="lineCov">     141797 : static void rm_shred_group_update_status(RmShredGroup *group) {</span>
<span class="lineNum">     952 </span><span class="lineCov">     141797 :     if(group-&gt;status == RM_SHRED_GROUP_DORMANT) {</span>
<span class="lineNum">     953 </span><span class="lineCov">      92224 :         if(1 &amp;&amp; group-&gt;num_files &gt;= 2 /* it takes 2 to tango */</span>
<span class="lineNum">     954 </span><span class="lineCov">      27161 :            &amp;&amp;</span>
<span class="lineNum">     955 </span><span class="lineCov">      52669 :            (group-&gt;has_pref || !NEEDS_PREF(group))</span>
<span class="lineNum">     956 </span>            :            /* we have at least one file from preferred path, or we don't care */
<span class="lineNum">     957 </span><span class="lineCov">      25792 :            &amp;&amp;</span>
<span class="lineNum">     958 </span><span class="lineCov">      26775 :            (group-&gt;has_npref || !NEEDS_NPREF(group))</span>
<span class="lineNum">     959 </span>            :            /* we have at least one file from non-pref path, or we don't care */
<span class="lineNum">     960 </span><span class="lineCov">      25140 :            &amp;&amp;</span>
<span class="lineNum">     961 </span><span class="lineCov">      25155 :            (group-&gt;has_new || !NEEDS_NEW(group))</span>
<span class="lineNum">     962 </span>            :            /* we have at least one file newer than cfg-&gt;min_mtime, or we don't care */
<span class="lineNum">     963 </span>            :            ) {
<span class="lineNum">     964 </span><span class="lineCov">      41179 :             if(group-&gt;hash_offset &lt; group-&gt;file_size &amp;&amp;</span>
<span class="lineNum">     965 </span><span class="lineCov">      16054 :                group-&gt;has_only_ext_cksums == false) {</span>
<span class="lineNum">     966 </span>            :                 /* group can go active */
<span class="lineNum">     967 </span><span class="lineCov">      15886 :                 group-&gt;status = RM_SHRED_GROUP_START_HASHING;</span>
<span class="lineNum">     968 </span>            :             } else {
<span class="lineNum">     969 </span><span class="lineCov">       9239 :                 group-&gt;status = RM_SHRED_GROUP_FINISHING;</span>
<span class="lineNum">     970 </span>            :             }
<span class="lineNum">     971 </span>            :         }
<span class="lineNum">     972 </span>            :     }
<span class="lineNum">     973 </span><span class="lineCov">     141797 : }</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /* Decrease reference count for RmShredGroup; dispose of group if reference count is 0.
<span class="lineNum">     976 </span>            :  * Each group has 1 reference for group-&gt;parent and one for each file that has not
<span class="lineNum">     977 </span>            :  * yet been hashed and moved to a child group.
<span class="lineNum">     978 </span>            :  * So rm_shred_group_unref can be called in 2 scenarios:
<span class="lineNum">     979 </span>            :  * 1. One of self's files is hashed and sent to rm_shred_sift, from where it is
<span class="lineNum">     980 </span>            :  *    moved into a new group.
<span class="lineNum">     981 </span>            :  * 2. Last file in self-&gt;parent group is sent to rm_shred_sift and is moved to a new group
<span class="lineNum">     982 </span>            :  *    (which may or may not be self).  Then rm_shred_sift calls
<span class="lineNum">     983 </span>            :  * rm_shred_group_unref(self-&gt;parent)
<span class="lineNum">     984 </span>            :  *    whereupon self-&gt;parent-&gt;ref_count will reach 0 and so rm_shred_group_unref will
<span class="lineNum">     985 </span>            :  *    call rm_shred_group_make_orphan(self) which in turn calls
<span class="lineNum">     986 </span>            :  * rm_shred_group_unref(self).
<span class="lineNum">     987 </span>            :  * Mutex management:
<span class="lineNum">     988 </span>            :  * In case (1), multiple threads may be sending files to rm_shred_sift which report to
<span class="lineNum">     989 </span>            :  * self. So
<span class="lineNum">     990 </span>            :  * rm_shred_group_unref locks self-&gt;lock before doing anything.
<span class="lineNum">     991 </span>            :  * In case (2), to prevent threadlock, need to unlock self-&gt;lock before
<a name="992"><span class="lineNum">     992 </span>            :  * calling rm_shred_group_unref(self-&gt;parent)</a>
<span class="lineNum">     993 </span>            :  * */
<span class="lineNum">     994 </span><span class="lineCov">     105243 : static void rm_shred_group_unref(RmShredGroup *self) {</span>
<span class="lineNum">     995 </span><span class="lineCov">     105243 :     bool needs_free = FALSE;</span>
<span class="lineNum">     996 </span><span class="lineCov">     105243 :     bool unref_parent = FALSE;</span>
<span class="lineNum">     997 </span><span class="lineCov">     105243 :     bool send_results = FALSE;</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineCov">     105243 :     g_mutex_lock(&amp;self-&gt;lock);</span>
<span class="lineNum">    1000 </span>            :     {
<span class="lineNum">    1001 </span><span class="lineCov">     105307 :         g_assert(self-&gt;ref_count &gt; 0);</span>
<span class="lineNum">    1002 </span><span class="lineCov">     105307 :         self-&gt;ref_count--;</span>
<span class="lineNum">    1003 </span><span class="lineCov">     105307 :         if(self-&gt;ref_count == 0) {</span>
<span class="lineNum">    1004 </span><span class="lineCov">      15884 :             rm_shred_mem_return(self);</span>
<span class="lineNum">    1005 </span>            :         }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineCov">     105296 :         switch(self-&gt;status) {</span>
<span class="lineNum">    1008 </span>            :         case RM_SHRED_GROUP_DORMANT:
<span class="lineNum">    1009 </span>            :             /* group is not going to receive any more files; do required clean-up */
<span class="lineNum">    1010 </span><span class="lineCov">      30203 :             needs_free = TRUE;</span>
<span class="lineNum">    1011 </span><span class="lineCov">      30203 :             unref_parent = TRUE;</span>
<span class="lineNum">    1012 </span><span class="lineCov">      30203 :             break;</span>
<span class="lineNum">    1013 </span>            :         case RM_SHRED_GROUP_FINISHING:
<span class="lineNum">    1014 </span>            :             /* groups is finished, and meets criteria for a duplicate group; send it to
<span class="lineNum">    1015 </span>            :              * finisher */
<span class="lineNum">    1016 </span>            :             /* note result_pool thread takes responsibility for cleanup of this group
<span class="lineNum">    1017 </span>            :              * after
<span class="lineNum">    1018 </span>            :              * processing results */
<span class="lineNum">    1019 </span><span class="lineCov">       9239 :             g_assert(self-&gt;children == NULL);</span>
<span class="lineNum">    1020 </span><span class="lineCov">       9239 :             if(self-&gt;parent == NULL) {</span>
<span class="lineNum">    1021 </span><span class="lineCov">       9239 :                 send_results = TRUE;</span>
<span class="lineNum">    1022 </span>            :             }
<span class="lineNum">    1023 </span><span class="lineCov">       9239 :             break;</span>
<span class="lineNum">    1024 </span>            :         case RM_SHRED_GROUP_START_HASHING:
<span class="lineNum">    1025 </span>            :         case RM_SHRED_GROUP_HASHING:
<span class="lineNum">    1026 </span><span class="lineCov">      65854 :             if(self-&gt;ref_count == 0) {</span>
<span class="lineNum">    1027 </span>            :                 /* group no longer required; tell the children we are about to die */
<span class="lineNum">    1028 </span><span class="lineCov">      15886 :                 if(self-&gt;children) {</span>
<span class="lineNum">    1029 </span><span class="lineCov">      15886 :                     GList *values = g_hash_table_get_values(self-&gt;children);</span>
<span class="lineNum">    1030 </span><span class="lineCov">      15886 :                     g_list_foreach(values, (GFunc)rm_shred_group_make_orphan, NULL);</span>
<span class="lineNum">    1031 </span><span class="lineCov">      15886 :                     g_list_free(values);</span>
<span class="lineNum">    1032 </span>            :                 }
<span class="lineNum">    1033 </span><span class="lineCov">      15886 :                 unref_parent = TRUE;</span>
<span class="lineNum">    1034 </span><span class="lineCov">      15886 :                 needs_free = TRUE;</span>
<span class="lineNum">    1035 </span>            :             }
<span class="lineNum">    1036 </span><span class="lineCov">      65854 :             break;</span>
<span class="lineNum">    1037 </span>            :         case RM_SHRED_GROUP_FINISHED:
<span class="lineNum">    1038 </span>            :         default:
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :             g_assert_not_reached();</span>
<span class="lineNum">    1040 </span>            :         }
<span class="lineNum">    1041 </span>            :     }
<span class="lineNum">    1042 </span><span class="lineCov">     105296 :     g_mutex_unlock(&amp;self-&gt;lock);</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineCov">     105307 :     if(unref_parent &amp;&amp; self-&gt;parent) {</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         rm_shred_group_unref(self-&gt;parent);</span>
<span class="lineNum">    1046 </span>            :     }
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span><span class="lineCov">     105313 :     if(send_results) {</span>
<span class="lineNum">    1049 </span><span class="lineCov">       9239 :         rm_util_thread_pool_push(self-&gt;main-&gt;result_pool, self);</span>
<span class="lineNum">    1050 </span>            :     }
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov">     105313 :     if(needs_free) {</span>
<span class="lineNum">    1053 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1054 </span>            :         rm_log_debug(&quot;Free from rm_shred_group_unref\n&quot;);
<span class="lineNum">    1055 </span>            : #endif
<span class="lineNum">    1056 </span><span class="lineCov">      46090 :         rm_shred_group_free(self);</span>
<span class="lineNum">    1057 </span>            :     }
<span class="lineNum">    1058 </span><span class="lineCov">     105308 : }</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : /* Only called by rm_shred_sift() or by rm_shred_group_unref. Call with group-&gt;lock
<a name="1061"><span class="lineNum">    1061 </span>            :  * unlocked.</a>
<span class="lineNum">    1062 </span>            :  */
<span class="lineNum">    1063 </span><span class="lineCov">      39485 : static void rm_shred_group_make_orphan(RmShredGroup *self) {</span>
<span class="lineNum">    1064 </span>            :     /* parent is dead */
<span class="lineNum">    1065 </span><span class="lineCov">      39485 :     self-&gt;parent = NULL;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :     /* reduce reference count for self and free self if possible */
<span class="lineNum">    1068 </span><span class="lineCov">      39485 :     rm_shred_group_unref(self);</span>
<span class="lineNum">    1069 </span><span class="lineCov">      39466 : }</span>
<span class="lineNum">    1070 </span>            : 
<a name="1071"><span class="lineNum">    1071 </span>            : /* Call with shred_group-&gt;lock unlocked.</a>
<span class="lineNum">    1072 </span>            :  * */
<span class="lineNum">    1073 </span><span class="lineCov">     141788 : static gboolean rm_shred_group_push_file(RmShredGroup *shred_group, RmFile *file,</span>
<span class="lineNum">    1074 </span>            :                                          gboolean initial) {
<span class="lineNum">    1075 </span><span class="lineCov">     141788 :     gboolean result = false;</span>
<span class="lineNum">    1076 </span><span class="lineCov">     141788 :     file-&gt;shred_group = shred_group;</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineCov">     141788 :     if(file-&gt;digest) {</span>
<span class="lineNum">    1079 </span><span class="lineCov">      65828 :         rm_digest_free(file-&gt;digest);</span>
<span class="lineNum">    1080 </span><span class="lineCov">      65835 :         file-&gt;digest = NULL;</span>
<span class="lineNum">    1081 </span>            :     }
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineCov">     141795 :     g_mutex_lock(&amp;shred_group-&gt;lock);</span>
<span class="lineNum">    1084 </span>            :     {
<span class="lineNum">    1085 </span><span class="lineCov">     141797 :         shred_group-&gt;has_pref |= file-&gt;is_prefd | file-&gt;hardlinks.has_prefd;</span>
<span class="lineNum">    1086 </span><span class="lineCov">     141797 :         shred_group-&gt;has_npref |= !file-&gt;is_prefd | file-&gt;hardlinks.has_non_prefd;</span>
<span class="lineNum">    1087 </span><span class="lineCov">     141797 :         shred_group-&gt;has_new |= file-&gt;is_new_or_has_new;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">     141797 :         shred_group-&gt;ref_count++;</span>
<span class="lineNum">    1090 </span><span class="lineCov">     141797 :         shred_group-&gt;num_files++;</span>
<span class="lineNum">    1091 </span><span class="lineCov">     141797 :         if(file-&gt;hardlinks.is_head) {</span>
<span class="lineNum">    1092 </span><span class="lineCov">        980 :             g_assert(file-&gt;hardlinks.files);</span>
<span class="lineNum">    1093 </span><span class="lineCov">        980 :             shred_group-&gt;num_files += file-&gt;hardlinks.files-&gt;length;</span>
<span class="lineNum">    1094 </span>            :         }
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineCov">     141797 :         g_assert(file-&gt;hash_offset == shred_group-&gt;hash_offset);</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineCov">     141797 :         rm_shred_group_update_status(shred_group);</span>
<span class="lineNum">    1099 </span><span class="lineCov">     141793 :         switch(shred_group-&gt;status) {</span>
<span class="lineNum">    1100 </span>            :         case RM_SHRED_GROUP_START_HASHING:
<span class="lineNum">    1101 </span>            :             /* clear the queue and push all its rmfiles to the appropriate device queue */
<span class="lineNum">    1102 </span><span class="lineCov">      38110 :             if(shred_group-&gt;held_files) {</span>
<span class="lineNum">    1103 </span><span class="lineCov">      15886 :                 g_queue_free_full(shred_group-&gt;held_files,</span>
<span class="lineNum">    1104 </span>            :                                   (GDestroyNotify)(initial ? rm_shred_push_queue
<span class="lineNum">    1105 </span>            :                                                            : rm_shred_push_queue_sorted));
<span class="lineNum">    1106 </span><span class="lineCov">      15886 :                 shred_group-&gt;held_files = NULL; /* won't need shred_group queue any more,</span>
<span class="lineNum">    1107 </span>            :                                                    since new arrivals will bypass */
<span class="lineNum">    1108 </span>            :             }
<span class="lineNum">    1109 </span><span class="lineCov">      38110 :             if(shred_group-&gt;digest_type == RM_DIGEST_PARANOID) {</span>
<span class="lineNum">    1110 </span><span class="lineCov">       3831 :                 rm_shred_check_hash_mem_alloc(shred_group, 1);</span>
<span class="lineNum">    1111 </span>            :             }
<span class="lineNum">    1112 </span>            :         /* FALLTHROUGH */
<span class="lineNum">    1113 </span>            :         case RM_SHRED_GROUP_HASHING:
<span class="lineNum">    1114 </span><span class="lineCov">      49435 :             if(initial || !file-&gt;devlist_waiting) {</span>
<span class="lineNum">    1115 </span>            :                 /* add file to device queue */
<span class="lineNum">    1116 </span><span class="lineCov">      49435 :                 g_assert(file-&gt;device);</span>
<span class="lineNum">    1117 </span><span class="lineCov">      49435 :                 rm_shred_push_queue(file);</span>
<span class="lineNum">    1118 </span>            :             } else {
<span class="lineNum">    1119 </span>            :                 /* calling routine will handle the file */
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                 result = true;</span>
<span class="lineNum">    1121 </span>            :             }
<span class="lineNum">    1122 </span><span class="lineCov">      49435 :             break;</span>
<span class="lineNum">    1123 </span>            :         case RM_SHRED_GROUP_DORMANT:
<span class="lineNum">    1124 </span><span class="lineCov">      67093 :             g_queue_push_head(shred_group-&gt;held_files, file);</span>
<span class="lineNum">    1125 </span><span class="lineCov">      67100 :             break;</span>
<span class="lineNum">    1126 </span>            :         case RM_SHRED_GROUP_FINISHING:
<span class="lineNum">    1127 </span>            :             /* add file to held_files */
<span class="lineNum">    1128 </span><span class="lineCov">      25263 :             g_queue_push_head(shred_group-&gt;held_files, file);</span>
<span class="lineNum">    1129 </span><span class="lineCov">      25263 :             break;</span>
<span class="lineNum">    1130 </span>            :         case RM_SHRED_GROUP_FINISHED:
<span class="lineNum">    1131 </span>            :         default:
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :             g_assert_not_reached();</span>
<span class="lineNum">    1133 </span>            :         }
<span class="lineNum">    1134 </span>            :     }
<span class="lineNum">    1135 </span><span class="lineCov">     141798 :     g_mutex_unlock(&amp;shred_group-&gt;lock);</span>
<span class="lineNum">    1136 </span><span class="lineCov">     141801 :     return result;</span>
<span class="lineNum">    1137 </span>            : }
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            : /* After partial hashing of RmFile, add it back into the sieve for further
<span class="lineNum">    1140 </span>            :  * hashing if required.  If waiting option is set, then try to return the
<span class="lineNum">    1141 </span>            :  * RmFile to the calling routine so it can continue with the next hashing
<span class="lineNum">    1142 </span>            :  * increment (this bypasses the normal device queue and so avoids an unnecessary
<span class="lineNum">    1143 </span>            :  * file seek operation ) returns true if the file can be immediately be hashed
<a name="1144"><span class="lineNum">    1144 </span>            :  * some more.</a>
<span class="lineNum">    1145 </span>            :  * */
<span class="lineNum">    1146 </span><span class="lineCov">      65835 : static gboolean rm_shred_sift(RmFile *file) {</span>
<span class="lineNum">    1147 </span><span class="lineCov">      65835 :     gboolean result = FALSE;</span>
<span class="lineNum">    1148 </span><span class="lineCov">      65835 :     g_assert(file);</span>
<span class="lineNum">    1149 </span><span class="lineCov">      65835 :     g_assert(file-&gt;shred_group);</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineCov">      65835 :     RmShredGroup *child_group = NULL;</span>
<span class="lineNum">    1152 </span><span class="lineCov">      65835 :     RmShredGroup *current_group = file-&gt;shred_group;</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineCov">      65835 :     if(file-&gt;status == RM_FILE_STATE_IGNORE) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :         rm_digest_free(file-&gt;digest);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         rm_shred_discard_file(file, true);</span>
<span class="lineNum">    1157 </span>            :     } else {
<span class="lineNum">    1158 </span><span class="lineCov">      65835 :         g_assert(file-&gt;digest);</span>
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineCov">      65835 :         if(file-&gt;digest-&gt;type == RM_DIGEST_PARANOID &amp;&amp; !file-&gt;is_symlink) {</span>
<span class="lineNum">    1161 </span><span class="lineCov">      18391 :             g_assert(file-&gt;digest-&gt;bytes ==</span>
<span class="lineNum">    1162 </span>            :                      current_group-&gt;next_offset - current_group-&gt;hash_offset);
<span class="lineNum">    1163 </span>            :         }
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :         /* check if there is already a descendent of current_group which
<span class="lineNum">    1166 </span>            :          * matches snap... if yes then move this file into it; if not then
<span class="lineNum">    1167 </span>            :          * create a new group */
<span class="lineNum">    1168 </span><span class="lineCov">      65835 :         g_mutex_lock(&amp;current_group-&gt;lock);</span>
<span class="lineNum">    1169 </span>            :         {
<span class="lineNum">    1170 </span><span class="lineCov">      65840 :             if(!current_group-&gt;children) {</span>
<span class="lineNum">    1171 </span>            :                 /* create child queue */
<span class="lineNum">    1172 </span><span class="lineCov">      15886 :                 current_group-&gt;children = g_hash_table_new((GHashFunc)rm_digest_hash,</span>
<span class="lineNum">    1173 </span>            :                                                            (GEqualFunc)rm_digest_equal);
<span class="lineNum">    1174 </span>            :             }
<span class="lineNum">    1175 </span><span class="lineCov">      65840 :             g_assert(current_group-&gt;children != NULL);</span>
<span class="lineNum">    1176 </span><span class="lineCov">      65840 :             child_group = g_hash_table_lookup(current_group-&gt;children, file-&gt;digest);</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">      65840 :             if(!child_group) {</span>
<span class="lineNum">    1179 </span><span class="lineCov">      39502 :                 child_group = rm_shred_group_new(file);</span>
<span class="lineNum">    1180 </span><span class="lineCov">      39498 :                 g_hash_table_insert(current_group-&gt;children, child_group-&gt;digest,</span>
<span class="lineNum">    1181 </span>            :                                     child_group);
<span class="lineNum">    1182 </span><span class="lineCov">      39493 :                 child_group-&gt;has_only_ext_cksums = current_group-&gt;has_only_ext_cksums;</span>
<span class="lineNum">    1183 </span>            :             }
<span class="lineNum">    1184 </span>            :         }
<span class="lineNum">    1185 </span><span class="lineCov">      65831 :         g_mutex_unlock(&amp;current_group-&gt;lock);</span>
<span class="lineNum">    1186 </span><span class="lineCov">      65836 :         result = rm_shred_group_push_file(child_group, file, FALSE);</span>
<span class="lineNum">    1187 </span>            :     }
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :     /* current_group now has one less file to process */
<span class="lineNum">    1190 </span><span class="lineCov">      65838 :     rm_shred_group_unref(current_group);</span>
<span class="lineNum">    1191 </span><span class="lineCov">      65825 :     return result;</span>
<span class="lineNum">    1192 </span>            : }
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            : ////////////////////////////////////
<span class="lineNum">    1195 </span>            : //  SHRED-SPECIFIC PREPROCESSING  //
<span class="lineNum">    1196 </span>            : ////////////////////////////////////
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            : /* Basically this unloads files from the initial list build (which has
<span class="lineNum">    1199 </span>            :  * hardlinks already grouped).
<span class="lineNum">    1200 </span>            :  * Outline:
<span class="lineNum">    1201 </span>            :  * 1. Use g_hash_table_foreach_remove to send RmFiles from node_table
<span class="lineNum">    1202 </span>            :  *    to size_groups via rm_shred_file_preprocess.
<span class="lineNum">    1203 </span>            :  * 2. Use g_hash_table_foreach_remove to delete all singleton and other
<span class="lineNum">    1204 </span>            :  *    non-qualifying groups from size_groups via rm_shred_group_preprocess.
<span class="lineNum">    1205 </span>            :  * 3. Use g_hash_table_foreach to do the FIEMAP lookup for all remaining
<a name="1206"><span class="lineNum">    1206 </span>            :  *        files via rm_shred_device_preprocess.</a>
<span class="lineNum">    1207 </span>            :  * */
<span class="lineNum">    1208 </span><span class="lineCov">      75959 : static void rm_shred_file_preprocess(_U gpointer key, RmFile *file, RmShredTag *main) {</span>
<span class="lineNum">    1209 </span>            :     /* initial population of RmShredDevice's and first level RmShredGroup's */
<span class="lineNum">    1210 </span><span class="lineCov">      75959 :     RmSession *session = main-&gt;session;</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineCov">      75959 :     g_assert(file);</span>
<span class="lineNum">    1213 </span><span class="lineCov">      75959 :     g_assert(session-&gt;tables-&gt;dev_table);</span>
<span class="lineNum">    1214 </span><span class="lineCov">      75959 :     g_assert(file-&gt;lint_type == RM_LINT_TYPE_DUPE_CANDIDATE);</span>
<span class="lineNum">    1215 </span><span class="lineCov">      75959 :     g_assert(file-&gt;file_size &gt; 0);</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">      75959 :     file-&gt;is_new_or_has_new = (file-&gt;mtime &gt;= session-&gt;cfg-&gt;min_mtime);</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :     /* if file has hardlinks then set file-&gt;hardlinks.has_[non_]prefd*/
<span class="lineNum">    1220 </span><span class="lineCov">      75959 :     if(file-&gt;hardlinks.is_head) {</span>
<span class="lineNum">    1221 </span><span class="lineCov">       1302 :         for(GList *iter = file-&gt;hardlinks.files-&gt;head; iter; iter = iter-&gt;next) {</span>
<span class="lineNum">    1222 </span><span class="lineCov">        812 :             RmFile *link = iter-&gt;data;</span>
<span class="lineNum">    1223 </span><span class="lineCov">        812 :             file-&gt;hardlinks.has_non_prefd |= !link-&gt;is_prefd;</span>
<span class="lineNum">    1224 </span><span class="lineCov">        812 :             file-&gt;hardlinks.has_prefd |= link-&gt;is_prefd;</span>
<span class="lineNum">    1225 </span><span class="lineCov">        812 :             file-&gt;is_new_or_has_new |= (link-&gt;mtime &gt;= session-&gt;cfg-&gt;min_mtime);</span>
<span class="lineNum">    1226 </span>            :         }
<span class="lineNum">    1227 </span>            :     }
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :     /* create RmShredDevice for this file if one doesn't exist yet */
<span class="lineNum">    1230 </span><span class="lineCov">      75959 :     RM_DEFINE_PATH(file);</span>
<span class="lineNum">    1231 </span><span class="lineCov">     151918 :     dev_t disk = (!session-&gt;cfg-&gt;fake_pathindex_as_disk</span>
<span class="lineNum">    1232 </span><span class="lineCov">      74076 :                       ? rm_mounts_get_disk_id(session-&gt;mounts, file-&gt;dev, file_path)</span>
<span class="lineNum">    1233 </span><span class="lineCov">     150035 :                       : (dev_t)file-&gt;path_index);</span>
<span class="lineNum">    1234 </span><span class="lineCov">      75959 :     RmShredDevice *device =</span>
<span class="lineNum">    1235 </span><span class="lineCov">      75959 :         g_hash_table_lookup(session-&gt;tables-&gt;dev_table, GUINT_TO_POINTER(disk));</span>
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineCov">      75959 :     if(device == NULL) {</span>
<span class="lineNum">    1238 </span><span class="lineCov">      13050 :         rm_log_debug(GREEN &quot;Creating new RmShredDevice for disk %u\n&quot; RESET,</span>
<span class="lineNum">    1239 </span>            :                      (unsigned)disk);
<span class="lineNum">    1240 </span><span class="lineCov">      13050 :         device =</span>
<span class="lineNum">    1241 </span><span class="lineCov">      25423 :             rm_shred_device_new(session-&gt;cfg-&gt;fake_pathindex_as_disk ||</span>
<span class="lineNum">    1242 </span><span class="lineCov">      12373 :                                     !rm_mounts_is_nonrotational(session-&gt;mounts, disk),</span>
<span class="lineNum">    1243 </span><span class="lineCov">      13050 :                                 rm_mounts_get_disk_name(session-&gt;mounts, disk),</span>
<span class="lineNum">    1244 </span>            :                                 main);
<span class="lineNum">    1245 </span><span class="lineCov">      13050 :         device-&gt;disk = disk;</span>
<span class="lineNum">    1246 </span><span class="lineCov">      13050 :         g_hash_table_insert(session-&gt;tables-&gt;dev_table, GUINT_TO_POINTER(disk), device);</span>
<span class="lineNum">    1247 </span>            :     }
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineCov">      75959 :     file-&gt;device = device;</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineCov">      75959 :     rm_shred_adjust_counters(device, 1, (gint64)file-&gt;file_size);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">      75959 :     RmShredGroup *group = g_hash_table_lookup(session-&gt;tables-&gt;size_groups, file);</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineCov">      75959 :     if(group == NULL) {</span>
<span class="lineNum">    1256 </span><span class="lineCov">      26042 :         group = rm_shred_group_new(file);</span>
<span class="lineNum">    1257 </span><span class="lineCov">      26042 :         group-&gt;digest_type = session-&gt;cfg-&gt;checksum_type;</span>
<span class="lineNum">    1258 </span><span class="lineCov">      26042 :         g_hash_table_insert(session-&gt;tables-&gt;size_groups, file, group);</span>
<span class="lineNum">    1259 </span>            :     }
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineCov">      75959 :     rm_shred_group_push_file(group, file, true);</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineCov">      75959 :     if(main-&gt;session-&gt;cfg-&gt;read_cksum_from_xattr) {</span>
<span class="lineNum">    1264 </span><span class="lineCov">       1218 :         char *ext_cksum = rm_xattr_read_hash(main-&gt;session, file);</span>
<span class="lineNum">    1265 </span><span class="lineCov">       1218 :         if(ext_cksum != NULL) {</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :             file-&gt;folder-&gt;data = ext_cksum;</span>
<span class="lineNum">    1267 </span>            :         }
<span class="lineNum">    1268 </span>            :     }
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">      75959 :     if(HAS_CACHE(session) &amp;&amp; rm_trie_search(&amp;session-&gt;cfg-&gt;file_trie, file_path)) {</span>
<span class="lineNum">    1271 </span><span class="lineCov">        504 :         group-&gt;num_ext_cksums += 1;</span>
<span class="lineNum">    1272 </span><span class="lineCov">        504 :         file-&gt;has_ext_cksum = 1;</span>
<span class="lineNum">    1273 </span>            :     }
<a name="1274"><span class="lineNum">    1274 </span><span class="lineCov">      75959 : }</span></a>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span><span class="lineCov">      26042 : static gboolean rm_shred_group_preprocess(_U gpointer key, RmShredGroup *group) {</span>
<span class="lineNum">    1277 </span><span class="lineCov">      26042 :     g_assert(group);</span>
<span class="lineNum">    1278 </span><span class="lineCov">      26042 :     if(group-&gt;status == RM_SHRED_GROUP_DORMANT) {</span>
<span class="lineNum">    1279 </span><span class="lineCov">      10188 :         rm_shred_group_free(group);</span>
<span class="lineNum">    1280 </span><span class="lineCov">      10188 :         return true;</span>
<span class="lineNum">    1281 </span>            :     } else {
<span class="lineNum">    1282 </span><span class="lineCov">      15854 :         return false;</span>
<span class="lineNum">    1283 </span>            :     }
<a name="1284"><span class="lineNum">    1284 </span>            : }</a>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">      13050 : static void rm_shred_device_preprocess(_U gpointer key, RmShredDevice *device,</span>
<span class="lineNum">    1287 </span>            :                                        RmShredTag *main) {
<span class="lineNum">    1288 </span><span class="lineCov">      13050 :     g_mutex_lock(&amp;device-&gt;lock);</span>
<span class="lineNum">    1289 </span><span class="lineCov">      13050 :     g_queue_foreach(device-&gt;file_queue, (GFunc)rm_shred_file_get_offset_table,</span>
<span class="lineNum">    1290 </span><span class="lineCov">      13050 :                     main-&gt;session);</span>
<span class="lineNum">    1291 </span><span class="lineCov">      13050 :     g_mutex_unlock(&amp;device-&gt;lock);</span>
<a name="1292"><span class="lineNum">    1292 </span><span class="lineCov">      13050 : }</span></a>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">      13188 : static void rm_shred_preprocess_input(RmShredTag *main) {</span>
<span class="lineNum">    1295 </span><span class="lineCov">      13188 :     RmSession *session = main-&gt;session;</span>
<span class="lineNum">    1296 </span><span class="lineCov">      13188 :     guint removed = 0;</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :     /* move remaining files to RmShredGroups */
<span class="lineNum">    1299 </span><span class="lineCov">      13188 :     g_assert(session-&gt;tables-&gt;node_table);</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :     /* Read any cache files */
<span class="lineNum">    1302 </span><span class="lineCov">      13281 :     for(GList *iter = main-&gt;session-&gt;cache_list.head; iter; iter = iter-&gt;next) {</span>
<span class="lineNum">    1303 </span><span class="lineCov">         93 :         char *cache_path = iter-&gt;data;</span>
<span class="lineNum">    1304 </span><span class="lineCov">         93 :         rm_json_cache_read(&amp;session-&gt;cfg-&gt;file_trie, cache_path);</span>
<span class="lineNum">    1305 </span>            :     }
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;Moving files into size groups...\n&quot;);</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :     /* move files from node tables into initial RmShredGroups */
<span class="lineNum">    1310 </span><span class="lineCov">      13188 :     g_hash_table_foreach_remove(session-&gt;tables-&gt;node_table,</span>
<span class="lineNum">    1311 </span>            :                                 (GHRFunc)rm_shred_file_preprocess, main);
<span class="lineNum">    1312 </span><span class="lineCov">      13188 :     g_hash_table_unref(session-&gt;tables-&gt;node_table);</span>
<span class="lineNum">    1313 </span><span class="lineCov">      13188 :     session-&gt;tables-&gt;node_table = NULL;</span>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            :     GHashTableIter iter;
<span class="lineNum">    1316 </span>            :     gpointer size, p_group;
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineCov">      13188 :     if(HAS_CACHE(main-&gt;session)) {</span>
<span class="lineNum">    1319 </span><span class="lineCov">        267 :         g_assert(session-&gt;tables-&gt;size_groups);</span>
<span class="lineNum">    1320 </span><span class="lineCov">        267 :         g_hash_table_iter_init(&amp;iter, session-&gt;tables-&gt;size_groups);</span>
<span class="lineNum">    1321 </span><span class="lineCov">       1161 :         while(g_hash_table_iter_next(&amp;iter, &amp;size, &amp;p_group)) {</span>
<span class="lineNum">    1322 </span><span class="lineCov">        627 :             RmShredGroup *group = p_group;</span>
<span class="lineNum">    1323 </span><span class="lineCov">        627 :             if(group-&gt;num_files == group-&gt;num_ext_cksums) {</span>
<span class="lineNum">    1324 </span><span class="lineCov">         84 :                 group-&gt;has_only_ext_cksums = true;</span>
<span class="lineNum">    1325 </span>            :             }
<span class="lineNum">    1326 </span>            :         }
<span class="lineNum">    1327 </span>            :     }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;move remaining files to size_groups finished at time %.3f\n&quot;,</span>
<span class="lineNum">    1330 </span>            :                  g_timer_elapsed(session-&gt;timer, NULL));
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;Discarding unique sizes and read fiemap data for others...&quot;);</span>
<span class="lineNum">    1333 </span><span class="lineCov">      13188 :     g_assert(session-&gt;tables-&gt;size_groups);</span>
<span class="lineNum">    1334 </span><span class="lineCov">      13188 :     removed = g_hash_table_foreach_remove(session-&gt;tables-&gt;size_groups,</span>
<span class="lineNum">    1335 </span>            :                                           (GHRFunc)rm_shred_group_preprocess, main);
<span class="lineNum">    1336 </span><span class="lineCov">      13188 :     g_hash_table_unref(session-&gt;tables-&gt;size_groups);</span>
<span class="lineNum">    1337 </span><span class="lineCov">      13188 :     session-&gt;tables-&gt;size_groups = NULL;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;done at time %.3f; removed %u of %&quot; LLU &quot;\n&quot;,</span>
<span class="lineNum">    1340 </span>            :                  g_timer_elapsed(session-&gt;timer, NULL), removed,
<span class="lineNum">    1341 </span>            :                  session-&gt;total_filtered_files);
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;Looking up fiemap data for files on rotational devices...&quot;);</span>
<span class="lineNum">    1344 </span><span class="lineCov">      13188 :     g_hash_table_foreach(session-&gt;tables-&gt;dev_table, (GHFunc)rm_shred_device_preprocess,</span>
<span class="lineNum">    1345 </span>            :                          main);
<span class="lineNum">    1346 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;done at time %.3f\n&quot;, g_timer_elapsed(session-&gt;timer, NULL));</span>
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">      13188 :     rm_log_debug(&quot;fiemap'd %&quot; LLU &quot; files containing %&quot; LLU</span>
<span class="lineNum">    1349 </span>            :                  &quot; fragments (failed another %&quot; LLU &quot; files)\n&quot;,
<span class="lineNum">    1350 </span>            :                  session-&gt;offsets_read - session-&gt;offset_fails, session-&gt;offset_fragments,
<span class="lineNum">    1351 </span>            :                  session-&gt;offset_fails);
<span class="lineNum">    1352 </span><span class="lineCov">      13188 : }</span>
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span>            : /////////////////////////////////
<span class="lineNum">    1355 </span>            : //       POST PROCESSING       //
<span class="lineNum">    1356 </span>            : /////////////////////////////////
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : /* post-processing sorting of files by criteria (-S and -[kmKM])
<span class="lineNum">    1359 </span>            :  * this is slightly different to rm_shred_cmp_orig_criteria in the case of
<a name="1360"><span class="lineNum">    1360 </span>            :  * either -K or -M options</a>
<span class="lineNum">    1361 </span>            :  */
<span class="lineNum">    1362 </span><span class="lineCov">      47486 : static int rm_shred_cmp_orig_criteria(RmFile *a, RmFile *b, RmSession *session) {</span>
<span class="lineNum">    1363 </span><span class="lineCov">      47486 :     RmCfg *cfg = session-&gt;cfg;</span>
<span class="lineNum">    1364 </span><span class="lineCov">      48673 :     if(1 &amp;&amp; (a-&gt;is_prefd != b-&gt;is_prefd) &amp;&amp;</span>
<span class="lineNum">    1365 </span><span class="lineCov">       2036 :        (cfg-&gt;keep_all_untagged || cfg-&gt;must_match_untagged)) {</span>
<span class="lineNum">    1366 </span><span class="lineCov">        505 :         return (a-&gt;is_prefd - b-&gt;is_prefd);</span>
<span class="lineNum">    1367 </span>            :     } else {
<span class="lineNum">    1368 </span><span class="lineCov">      46981 :         int comparasion = rm_pp_cmp_orig_criteria(a, b, session);</span>
<span class="lineNum">    1369 </span><span class="lineCov">      46981 :         if(comparasion == 0) {</span>
<span class="lineNum">    1370 </span><span class="lineCov">      18012 :             return b-&gt;is_original - a-&gt;is_original;</span>
<span class="lineNum">    1371 </span>            :         }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineCov">      28969 :         return comparasion;</span>
<span class="lineNum">    1374 </span>            :     }
<span class="lineNum">    1375 </span>            : }
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            : /* iterate over group to find highest ranked; return it and tag it as original    */
<span class="lineNum">    1378 </span>            : /* also in special cases (eg keep_all_tagged) there may be more than one original,
<a name="1379"><span class="lineNum">    1379 </span>            :  * in which case tag them as well</a>
<span class="lineNum">    1380 </span>            :  */
<span class="lineNum">    1381 </span><span class="lineCov">      11883 : void rm_shred_group_find_original(RmSession *session, GQueue *group) {</span>
<span class="lineNum">    1382 </span>            :     /* iterate over group, unbundling hardlinks and identifying &quot;tagged&quot; originals */
<span class="lineNum">    1383 </span><span class="lineCov">      54280 :     for(GList *iter = group-&gt;head; iter; iter = iter-&gt;next) {</span>
<span class="lineNum">    1384 </span><span class="lineCov">      42397 :         RmFile *file = iter-&gt;data;</span>
<span class="lineNum">    1385 </span><span class="lineCov">      42397 :         file-&gt;is_original = false;</span>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineCov">      42397 :         if(file-&gt;hardlinks.is_head &amp;&amp; file-&gt;hardlinks.files) {</span>
<span class="lineNum">    1388 </span>            :             /* if group member has a hardlink cluster attached to it then
<span class="lineNum">    1389 </span>            :              * unbundle the cluster and append it to the queue
<span class="lineNum">    1390 </span>            :              */
<span class="lineNum">    1391 </span><span class="lineCov">        490 :             GQueue *hardlinks = file-&gt;hardlinks.files;</span>
<span class="lineNum">    1392 </span><span class="lineCov">       1302 :             for(GList *link = hardlinks-&gt;head; link; link = link-&gt;next) {</span>
<span class="lineNum">    1393 </span><span class="lineCov">        812 :                 g_queue_push_tail(group, link-&gt;data);</span>
<span class="lineNum">    1394 </span>            :             }
<span class="lineNum">    1395 </span><span class="lineCov">        490 :             g_queue_free(hardlinks);</span>
<span class="lineNum">    1396 </span><span class="lineCov">        490 :             file-&gt;hardlinks.files = NULL;</span>
<span class="lineNum">    1397 </span>            :         }
<span class="lineNum">    1398 </span>            :         /* identify &quot;tagged&quot; originals: */
<span class="lineNum">    1399 </span><span class="lineCov">      84470 :         if(((file-&gt;is_prefd) &amp;&amp; (session-&gt;cfg-&gt;keep_all_tagged)) ||</span>
<span class="lineNum">    1400 </span><span class="lineCov">      82850 :            ((!file-&gt;is_prefd) &amp;&amp; (session-&gt;cfg-&gt;keep_all_untagged))) {</span>
<span class="lineNum">    1401 </span><span class="lineCov">        648 :             file-&gt;is_original = true;</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1404 </span>            :             RM_DEFINE_PATH(file);
<span class="lineNum">    1405 </span>            :             rm_log_debug(&quot;tagging %s as original because %s\n&quot;,
<span class="lineNum">    1406 </span>            :                          file_path,
<span class="lineNum">    1407 </span>            :                          ((file-&gt;is_prefd) &amp;&amp; (session-&gt;cfg-&gt;keep_all_tagged))
<span class="lineNum">    1408 </span>            :                              ? &quot;tagged&quot;
<span class="lineNum">    1409 </span>            :                              : &quot;untagged&quot;);
<span class="lineNum">    1410 </span>            : #endif
<span class="lineNum">    1411 </span>            :         }
<span class="lineNum">    1412 </span>            :     }
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :     /* sort the unbundled group */
<span class="lineNum">    1415 </span><span class="lineCov">      11883 :     g_queue_sort(group, (GCompareDataFunc)rm_shred_cmp_orig_criteria, session);</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineCov">      11883 :     RmFile *headfile = group-&gt;head-&gt;data;</span>
<span class="lineNum">    1418 </span><span class="lineCov">      11883 :     if(!headfile-&gt;is_original) {</span>
<span class="lineNum">    1419 </span><span class="lineCov">      11559 :         headfile-&gt;is_original = true;</span>
<span class="lineNum">    1420 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1421 </span>            :         RM_DEFINE_PATH(headfile);
<span class="lineNum">    1422 </span>            :         rm_log_debug(&quot;tagging %s as original because it is highest ranked\n&quot;,
<span class="lineNum">    1423 </span>            :                      headfile_path);
<span class="lineNum">    1424 </span>            : #endif
<span class="lineNum">    1425 </span>            :     }
<a name="1426"><span class="lineNum">    1426 </span><span class="lineCov">      11883 : }</span></a>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineCov">       9988 : void rm_shred_forward_to_output(RmSession *session, GQueue *group) {</span>
<span class="lineNum">    1429 </span><span class="lineCov">       9988 :     g_assert(group);</span>
<span class="lineNum">    1430 </span><span class="lineCov">       9988 :     g_assert(group-&gt;head);</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1433 </span>            :     RmFile *head = group-&gt;head-&gt;data;
<span class="lineNum">    1434 </span>            :     RM_DEFINE_PATH(head);
<span class="lineNum">    1435 </span>            :     rm_log_debug(&quot;Forwarding %s's group\n&quot;, head_path);
<span class="lineNum">    1436 </span>            : #endif
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            :     /* Hand it over to the printing module */
<span class="lineNum">    1439 </span><span class="lineCov">       9988 :     g_queue_foreach(group, (GFunc)rm_fmt_write, session-&gt;formats);</span>
<a name="1440"><span class="lineNum">    1440 </span><span class="lineCov">       9988 : }</span></a>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span><span class="lineCov">      35366 : static void rm_shred_dupe_totals(RmFile *file, RmSession *session) {</span>
<span class="lineNum">    1443 </span><span class="lineCov">      35366 :     if(!file-&gt;is_original) {</span>
<span class="lineNum">    1444 </span><span class="lineCov">      25803 :         session-&gt;dup_counter++;</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            :         /* Only check file size if it's not a hardlink.
<span class="lineNum">    1447 </span>            :          * Since deleting hardlinks does not free any space
<span class="lineNum">    1448 </span>            :          * they should not be counted unless all of them would
<span class="lineNum">    1449 </span>            :          * be removed.
<span class="lineNum">    1450 </span>            :          */
<span class="lineNum">    1451 </span><span class="lineCov">      25803 :         if(file-&gt;hardlinks.is_head || file-&gt;hardlinks.hardlink_head == NULL) {</span>
<span class="lineNum">    1452 </span><span class="lineCov">      24991 :             session-&gt;total_lint_size += file-&gt;file_size;</span>
<span class="lineNum">    1453 </span>            :         }
<span class="lineNum">    1454 </span>            :     }
<a name="1455"><span class="lineNum">    1455 </span><span class="lineCov">      35366 : }</span></a>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineCov">       9239 : static void rm_shred_result_factory(RmShredGroup *group, RmShredTag *tag) {</span>
<span class="lineNum">    1458 </span><span class="lineCov">       9239 :     if(g_queue_get_length(group-&gt;held_files) &gt; 0) {</span>
<span class="lineNum">    1459 </span>            :         /* find the original(s)
<span class="lineNum">    1460 </span>            :          * (note this also unbundles hardlinks and sorts the group from
<span class="lineNum">    1461 </span>            :          *  highest ranked to lowest ranked
<span class="lineNum">    1462 </span>            :          */
<span class="lineNum">    1463 </span><span class="lineCov">       9239 :         rm_shred_group_find_original(tag-&gt;session, group-&gt;held_files);</span>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            :         /* Update statistics */
<span class="lineNum">    1466 </span><span class="lineCov">       9239 :         rm_fmt_lock_state(tag-&gt;session-&gt;formats);</span>
<span class="lineNum">    1467 </span>            :         {
<span class="lineNum">    1468 </span><span class="lineCov">       9239 :             tag-&gt;session-&gt;dup_group_counter++;</span>
<span class="lineNum">    1469 </span><span class="lineCov">       9239 :             g_queue_foreach(group-&gt;held_files, (GFunc)rm_shred_dupe_totals, tag-&gt;session);</span>
<span class="lineNum">    1470 </span>            :         }
<span class="lineNum">    1471 </span><span class="lineCov">       9239 :         rm_fmt_unlock_state(tag-&gt;session-&gt;formats);</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :         /* Cache the files for merging them into directories */
<span class="lineNum">    1474 </span><span class="lineCov">      44605 :         for(GList *iter = group-&gt;held_files-&gt;head; iter; iter = iter-&gt;next) {</span>
<span class="lineNum">    1475 </span><span class="lineCov">      35366 :             RmFile *file = iter-&gt;data;</span>
<span class="lineNum">    1476 </span><span class="lineCov">      35366 :             file-&gt;digest = group-&gt;digest;</span>
<span class="lineNum">    1477 </span><span class="lineCov">      35366 :             file-&gt;free_digest = false;</span>
<span class="lineNum">    1478 </span><span class="lineCov">      35366 :             if(tag-&gt;session-&gt;cfg-&gt;merge_directories) {</span>
<span class="lineNum">    1479 </span><span class="lineCov">      13953 :                 rm_tm_feed(tag-&gt;session-&gt;dir_merger, file);</span>
<span class="lineNum">    1480 </span>            :             }
<span class="lineNum">    1481 </span>            :         }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">       9239 :         if(tag-&gt;session-&gt;cfg-&gt;merge_directories == false) {</span>
<span class="lineNum">    1484 </span>            :             /* Output them directly */
<span class="lineNum">    1485 </span><span class="lineCov">       5174 :             rm_shred_forward_to_output(tag-&gt;session, group-&gt;held_files);</span>
<span class="lineNum">    1486 </span>            :         }
<span class="lineNum">    1487 </span>            :     }
<span class="lineNum">    1488 </span><span class="lineCov">       9239 :     group-&gt;status = RM_SHRED_GROUP_FINISHED;</span>
<span class="lineNum">    1489 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1490 </span>            :     rm_log_debug(&quot;Free from rm_shred_result_factory\n&quot;);
<span class="lineNum">    1491 </span>            : #endif
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            :     /* TODO:
<span class="lineNum">    1494 </span>            :      * With -D we get a memory leak here. Which is not that bad,
<span class="lineNum">    1495 </span>            :      * since all files need to be cached till the end of the run
<span class="lineNum">    1496 </span>            :      * anyways, but valgrind shows a lot of output.
<span class="lineNum">    1497 </span>            :      *
<span class="lineNum">    1498 </span>            :      * (we're leaking group-&gt;digest and all RmFiles in it)
<span class="lineNum">    1499 </span>            :      */
<span class="lineNum">    1500 </span><span class="lineCov">       9239 :     rm_shred_group_free(group);</span>
<span class="lineNum">    1501 </span><span class="lineCov">       9239 : }</span>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            : /////////////////////////////////
<span class="lineNum">    1504 </span>            : //    ACTUAL IMPLEMENTATION    //
<a name="1505"><span class="lineNum">    1505 </span>            : /////////////////////////////////</a>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineCov">      65075 : static void rm_shred_request_readahead(int fd, RmFile *file, RmOff bytes_to_read) {</span>
<span class="lineNum">    1508 </span>            :     /* Give the kernel scheduler some hints */
<span class="lineNum">    1509 </span><span class="lineCov">      65075 :     if(file-&gt;fadvise_requested) {</span>
<span class="lineNum">    1510 </span><span class="lineCov">        271 :         RmOff readahead = MIN(file-&gt;file_size - file-&gt;seek_offset, bytes_to_read * 8);</span>
<span class="lineNum">    1511 </span><span class="lineCov">        271 :         posix_fadvise(fd, file-&gt;seek_offset, readahead, SHRED_FADVISE_FLAGS);</span>
<span class="lineNum">    1512 </span><span class="lineCov">        271 :         file-&gt;fadvise_requested = 1;</span>
<span class="lineNum">    1513 </span>            :     }
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">      65075 : }</span></a>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineCov">        264 : static void rm_shred_readlink_factory(RmFile *file, RmShredDevice *device) {</span>
<span class="lineNum">    1517 </span><span class="lineCov">        264 :     g_assert(file-&gt;is_symlink);</span>
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            :     /* Fake an IO operation on the symlink.
<span class="lineNum">    1520 </span>            :      */
<span class="lineNum">    1521 </span>            :     char id_buf[256];
<span class="lineNum">    1522 </span><span class="lineCov">        264 :     memset(id_buf, 0, sizeof(id_buf));</span>
<span class="lineNum">    1523 </span><span class="lineCov">        264 :     RM_DEFINE_PATH(file);</span>
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            :     RmStat stat_buf;
<span class="lineNum">    1526 </span><span class="lineCov">        264 :     if(rm_sys_stat(file_path, &amp;stat_buf) == -1) {</span>
<span class="lineNum">    1527 </span>            :         /* Oops, that did not work out, report as an error */
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         rm_log_perror(&quot;Cannot stat symbolic link&quot;);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1530 </span><span class="lineCov">        264 :         return;</span>
<span class="lineNum">    1531 </span>            :     }
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineCov">        264 :     file-&gt;status = RM_FILE_STATE_NORMAL;</span>
<span class="lineNum">    1534 </span><span class="lineCov">        264 :     file-&gt;seek_offset = file-&gt;file_size;</span>
<span class="lineNum">    1535 </span><span class="lineCov">        264 :     file-&gt;hash_offset = file-&gt;file_size;</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">        264 :     g_assert(file-&gt;digest);</span>
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineCov">        264 :     gint data_size = snprintf(id_buf, sizeof(id_buf), &quot;%ld:%ld&quot;, (long)stat_buf.st_dev,</span>
<span class="lineNum">    1540 </span><span class="lineCov">        264 :                               (long)stat_buf.st_ino);</span>
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineCov">        264 :     rm_digest_update(file-&gt;digest, (unsigned char *)id_buf, data_size);</span>
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            :     /* In case of paranoia: shrink the used data buffer, so comparasion works
<span class="lineNum">    1545 </span>            :      * as expected. Otherwise a full buffer is used with possibly different
<span class="lineNum">    1546 </span>            :      * content */
<span class="lineNum">    1547 </span><span class="lineCov">        264 :     if(file-&gt;digest-&gt;type == RM_DIGEST_PARANOID) {</span>
<span class="lineNum">    1548 </span><span class="lineCov">        121 :         rm_digest_paranoia_shrink(file-&gt;digest, data_size);</span>
<span class="lineNum">    1549 </span>            :     }
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span><span class="lineCov">        264 :     rm_shred_adjust_counters(device, 0, -(gint64)file-&gt;file_size);</span>
<a name="1552"><span class="lineNum">    1552 </span>            : }</a>
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineCov">       1697 : static void rm_shred_buffered_read_factory(RmFile *file, RmShredDevice *device) {</span>
<span class="lineNum">    1555 </span><span class="lineCov">       1697 :     FILE *fd = NULL;</span>
<span class="lineNum">    1556 </span><span class="lineCov">       1697 :     gint32 total_bytes_read = 0;</span>
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineCov">       1697 :     gint32 buf_size = rm_buffer_pool_size(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1559 </span><span class="lineCov">       1697 :     buf_size -= offsetof(RmBuffer, data);</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineCov">       1697 :     RmBuffer *buffer = rm_buffer_pool_get(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">       1697 :     GThreadPool *hash_pool = g_async_queue_pop(device-&gt;main-&gt;hash_pool_pool);</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineCov">       1697 :     if(file-&gt;seek_offset &gt;= file-&gt;file_size) {</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1567 </span>            :     }
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineCov">       1697 :     RM_DEFINE_PATH(file);</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span><span class="lineCov">       1697 :     if((fd = fopen(file_path, &quot;rb&quot;)) == NULL) {</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :         rm_log_info(&quot;fopen(3) failed for %s: %s&quot;, file_path, g_strerror(errno));</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1575 </span>            :     }
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineCov">       1697 :     gint32 bytes_to_read = rm_shred_get_read_size(file, device-&gt;main);</span>
<span class="lineNum">    1578 </span><span class="lineCov">       1697 :     gint32 bytes_read = 0;</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineCov">       1697 :     rm_shred_request_readahead(fileno(fd), file, bytes_to_read);</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span><span class="lineCov">       1697 :     if(fseek(fd, file-&gt;seek_offset, SEEK_SET) == -1) {</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :         rm_log_perror(&quot;fseek(3) failed&quot;);</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1586 </span>            :     }
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineCov">       1697 :     posix_fadvise(fileno(fd), file-&gt;seek_offset, bytes_to_read, SHRED_FADVISE_FLAGS);</span>
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span><span class="lineCov">       5091 :     while((bytes_read = fread(buffer-&gt;data, 1, MIN(bytes_to_read, buf_size), fd)) &gt; 0) {</span>
<span class="lineNum">    1591 </span><span class="lineCov">       1697 :         file-&gt;seek_offset += bytes_read;</span>
<span class="lineNum">    1592 </span><span class="lineCov">       1697 :         bytes_to_read -= bytes_read;</span>
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span><span class="lineCov">       1697 :         buffer-&gt;file = file;</span>
<span class="lineNum">    1595 </span><span class="lineCov">       1697 :         buffer-&gt;len = bytes_read;</span>
<span class="lineNum">    1596 </span><span class="lineCov">       1697 :         buffer-&gt;finished = FALSE;</span>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">       1697 :         rm_util_thread_pool_push(hash_pool, buffer);</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineCov">       1697 :         total_bytes_read += bytes_read;</span>
<span class="lineNum">    1601 </span><span class="lineCov">       1697 :         buffer = rm_buffer_pool_get(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1602 </span>            :     }
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineCov">       1697 :     file-&gt;current_disk_offset = rm_offset_lookup(file-&gt;disk_offsets, file-&gt;seek_offset);</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineCov">       1697 :     if(ferror(fd) != 0) {</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :         rm_log_perror(&quot;fread(3) failed&quot;);</span>
<span class="lineNum">    1609 </span>            :     }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : finish:
<span class="lineNum">    1612 </span><span class="lineCov">       1697 :     if(fd != NULL) {</span>
<span class="lineNum">    1613 </span><span class="lineCov">       1697 :         fclose(fd);</span>
<span class="lineNum">    1614 </span>            :     }
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span>            :     /* tell the hasher we have finished */
<span class="lineNum">    1617 </span><span class="lineCov">       1697 :     buffer-&gt;file = file;</span>
<span class="lineNum">    1618 </span><span class="lineCov">       1697 :     buffer-&gt;finished = TRUE;</span>
<span class="lineNum">    1619 </span><span class="lineCov">       1697 :     rm_util_thread_pool_push(hash_pool, buffer);</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :     /* recycle our hash_pool */
<span class="lineNum">    1622 </span><span class="lineCov">       1697 :     g_async_queue_push(device-&gt;main-&gt;hash_pool_pool, hash_pool);</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :     /* Update totals for device and session*/
<span class="lineNum">    1625 </span><span class="lineCov">       1697 :     rm_shred_adjust_counters(device, 0, -(gint64)total_bytes_read);</span>
<span class="lineNum">    1626 </span><span class="lineCov">       1697 : }</span>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            : /* Read from file and send to hasher
<span class="lineNum">    1629 </span>            :  * Note this was initially a separate thread but is currently just called
<a name="1630"><span class="lineNum">    1630 </span>            :  * directly from rm_devlist_factory.</a>
<span class="lineNum">    1631 </span>            :  * */
<span class="lineNum">    1632 </span><span class="lineCov">      63378 : static void rm_shred_unbuffered_read_factory(RmFile *file, RmShredDevice *device) {</span>
<span class="lineNum">    1633 </span><span class="lineCov">      63378 :     gint32 bytes_read = 0;</span>
<span class="lineNum">    1634 </span><span class="lineCov">      63378 :     gint32 total_bytes_read = 0;</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineCov">      63378 :     GThreadPool *hash_pool = g_async_queue_pop(device-&gt;main-&gt;hash_pool_pool);</span>
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span><span class="lineCov">      63378 :     RmOff buf_size = rm_buffer_pool_size(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1639 </span><span class="lineCov">      63378 :     buf_size -= offsetof(RmBuffer, data);</span>
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineCov">      63378 :     gint32 bytes_to_read = rm_shred_get_read_size(file, device-&gt;main);</span>
<span class="lineNum">    1642 </span><span class="lineCov">      63377 :     gint32 bytes_left_to_read = bytes_to_read;</span>
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineCov">      63377 :     g_assert(!file-&gt;is_symlink);</span>
<span class="lineNum">    1645 </span><span class="lineCov">      63377 :     g_assert(bytes_to_read &gt; 0);</span>
<span class="lineNum">    1646 </span><span class="lineCov">      63377 :     g_assert(bytes_to_read + file-&gt;hash_offset &lt;= file-&gt;file_size);</span>
<span class="lineNum">    1647 </span><span class="lineCov">      63377 :     g_assert(file-&gt;seek_offset == file-&gt;hash_offset);</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            :     /* how many buffers to read? */
<span class="lineNum">    1650 </span><span class="lineCov">      63377 :     const gint16 N_BUFFERS = MIN(4, DIVIDE_CEIL(bytes_to_read, buf_size));</span>
<span class="lineNum">    1651 </span><span class="lineCov">     126755 :     struct iovec readvec[N_BUFFERS + 1];</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineCov">      63377 :     int fd = 0;</span>
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineCov">      63377 :     if(file-&gt;seek_offset &gt;= file-&gt;file_size) {</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span><span class="lineCov">      63377 :     RM_DEFINE_PATH(file);</span>
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineCov">      63378 :     fd = rm_sys_open(file_path, O_RDONLY);</span>
<span class="lineNum">    1662 </span><span class="lineCov">      63377 :     if(fd == -1) {</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :         rm_log_info(&quot;open(2) failed for %s: %s&quot;, file_path, g_strerror(errno));</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1666 </span>            :     }
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :     /* preadv() is beneficial for large files since it can cut the
<span class="lineNum">    1669 </span>            :      * number of syscall heavily.  I suggest N_BUFFERS=4 as good
<span class="lineNum">    1670 </span>            :      * compromise between memory and cpu.
<span class="lineNum">    1671 </span>            :      *
<span class="lineNum">    1672 </span>            :      * With 16 buffers: 43% cpu 33,871 total
<span class="lineNum">    1673 </span>            :      * With  8 buffers: 43% cpu 32,098 total
<span class="lineNum">    1674 </span>            :      * With  4 buffers: 42% cpu 32,091 total
<span class="lineNum">    1675 </span>            :      * With  2 buffers: 44% cpu 32,245 total
<span class="lineNum">    1676 </span>            :      * With  1 buffers: 45% cpu 34,491 total
<span class="lineNum">    1677 </span>            :      */
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            :     /* Give the kernel scheduler some hints */
<span class="lineNum">    1680 </span><span class="lineCov">      63377 :     rm_shred_request_readahead(fd, file, bytes_to_read);</span>
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :     /* Initialize the buffers to begin with.
<span class="lineNum">    1683 </span>            :      * After a buffer is full, a new one is retrieved.
<span class="lineNum">    1684 </span>            :      */
<span class="lineNum">    1685 </span><span class="lineCov">      63378 :     memset(readvec, 0, sizeof(readvec));</span>
<span class="lineNum">    1686 </span><span class="lineCov">     128672 :     for(int i = 0; i &lt; N_BUFFERS; ++i) {</span>
<span class="lineNum">    1687 </span>            :         /* buffer is one contignous memory block */
<span class="lineNum">    1688 </span><span class="lineCov">      65294 :         RmBuffer *buffer = rm_buffer_pool_get(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1689 </span><span class="lineCov">      65294 :         readvec[i].iov_base = buffer-&gt;data;</span>
<span class="lineNum">    1690 </span><span class="lineCov">      65294 :         readvec[i].iov_len = buf_size;</span>
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineCov">     255136 :     while(bytes_left_to_read &gt; 0 &amp;&amp;</span>
<span class="lineNum">    1694 </span><span class="lineCov">      64190 :           (bytes_read = rm_sys_preadv(fd, readvec, N_BUFFERS, file-&gt;seek_offset)) &gt; 0) {</span>
<span class="lineNum">    1695 </span><span class="lineCov">      64189 :         bytes_read = MIN(bytes_read, bytes_left_to_read); /* ignore over-reads */</span>
<span class="lineNum">    1696 </span><span class="lineCov">      64189 :         int blocks = DIVIDE_CEIL(bytes_read, buf_size);</span>
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineCov">      64189 :         bytes_left_to_read -= bytes_read;</span>
<span class="lineNum">    1699 </span><span class="lineCov">      64189 :         file-&gt;seek_offset += bytes_read;</span>
<span class="lineNum">    1700 </span><span class="lineCov">      64189 :         total_bytes_read += bytes_read;</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineCov">     132287 :         for(int i = 0; i &lt; blocks; ++i) {</span>
<span class="lineNum">    1703 </span>            :             /* Get the RmBuffer from the datapointer */
<span class="lineNum">    1704 </span><span class="lineCov">      68096 :             RmBuffer *buffer = readvec[i].iov_base - offsetof(RmBuffer, data);</span>
<span class="lineNum">    1705 </span><span class="lineCov">      68096 :             buffer-&gt;file = file;</span>
<span class="lineNum">    1706 </span><span class="lineCov">      68096 :             buffer-&gt;len = MIN(buf_size, bytes_read - i * buf_size);</span>
<span class="lineNum">    1707 </span><span class="lineCov">      68096 :             buffer-&gt;finished = FALSE;</span>
<span class="lineNum">    1708 </span><span class="lineCov">      68096 :             if(bytes_left_to_read &lt; 0) {</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                 rm_log_error_line(_(&quot;Negative bytes_left_to_read for %s&quot;), file_path);</span>
<span class="lineNum">    1710 </span>            :             }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :             /* Send it to the hasher */
<span class="lineNum">    1713 </span><span class="lineCov">      68096 :             rm_util_thread_pool_push(hash_pool, buffer);</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :             /* Allocate a new buffer - hasher will release the old buffer */
<span class="lineNum">    1716 </span><span class="lineCov">      68098 :             buffer = rm_buffer_pool_get(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1717 </span><span class="lineCov">      68098 :             readvec[i].iov_base = buffer-&gt;data;</span>
<span class="lineNum">    1718 </span><span class="lineCov">      68098 :             readvec[i].iov_len = buf_size;</span>
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span>            :     }
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span><span class="lineCov">      63379 :     file-&gt;current_disk_offset = rm_offset_lookup(file-&gt;disk_offsets, file-&gt;seek_offset);</span>
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">      63378 :     if(bytes_read == -1) {</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :         rm_log_perror(&quot;preadv failed&quot;);</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :         goto finish;</span>
<span class="lineNum">    1728 </span><span class="lineCov">      63378 :     } else if(total_bytes_read != bytes_to_read) {</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :         rm_log_error_line(_(&quot;Something went wrong reading %s; expected %d bytes, &quot;</span>
<span class="lineNum">    1730 </span>            :                             &quot;got %d; ignoring&quot;),
<span class="lineNum">    1731 </span>            :                           file_path, bytes_to_read, total_bytes_read);
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :         file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1733 </span>            :     }
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            :     /* Release the rest of the buffers */
<span class="lineNum">    1736 </span><span class="lineCov">     128672 :     for(int i = 0; i &lt; N_BUFFERS; ++i) {</span>
<span class="lineNum">    1737 </span><span class="lineCov">      65294 :         RmBuffer *buffer = readvec[i].iov_base - offsetof(RmBuffer, data);</span>
<span class="lineNum">    1738 </span><span class="lineCov">      65294 :         rm_buffer_pool_release(device-&gt;main-&gt;mem_pool, buffer);</span>
<span class="lineNum">    1739 </span>            :     }
<span class="lineNum">    1740 </span>            : finish:
<span class="lineNum">    1741 </span><span class="lineCov">      63378 :     if(fd &gt; 0) {</span>
<span class="lineNum">    1742 </span><span class="lineCov">      63378 :         rm_sys_close(fd);</span>
<span class="lineNum">    1743 </span>            :     }
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            :     /* tell the hasher we have finished via a dummy buffer*/
<span class="lineNum">    1746 </span><span class="lineCov">      63378 :     RmBuffer *buffer = rm_buffer_pool_get(device-&gt;main-&gt;mem_pool);</span>
<span class="lineNum">    1747 </span><span class="lineCov">      63378 :     buffer-&gt;file = file;</span>
<span class="lineNum">    1748 </span><span class="lineCov">      63378 :     buffer-&gt;finished = TRUE;</span>
<span class="lineNum">    1749 </span><span class="lineCov">      63378 :     rm_util_thread_pool_push(hash_pool, buffer);</span>
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span>            :     /* recycle our hash_pool */
<span class="lineNum">    1752 </span><span class="lineCov">      63378 :     g_async_queue_push(device-&gt;main-&gt;hash_pool_pool, hash_pool);</span>
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            :     /* Update totals for device and session*/
<span class="lineNum">    1755 </span><span class="lineCov">      63378 :     rm_shred_adjust_counters(device, 0, -(gint64)total_bytes_read);</span>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineCov">      63378 : }</span></a>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span><span class="lineCov">      67070 : static bool rm_shred_reassign_checksum(RmShredTag *main, RmFile *file) {</span>
<span class="lineNum">    1759 </span><span class="lineCov">      67070 :     bool can_process = true;</span>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span><span class="lineCov">      67070 :     if(file-&gt;shred_group-&gt;has_only_ext_cksums) {</span>
<span class="lineNum">    1762 </span>            :         /* Cool, we were able to read the checksum from disk */
<span class="lineNum">    1763 </span><span class="lineCov">        504 :         file-&gt;digest = rm_digest_new(RM_DIGEST_EXT, 0, 0, 0);</span>
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineCov">        504 :         RM_DEFINE_PATH(file);</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">        504 :         char *hexstring = file-&gt;folder-&gt;data;</span>
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span><span class="lineCov">        504 :         if(hexstring != NULL) {</span>
<span class="lineNum">    1770 </span><span class="lineCov">        504 :             rm_digest_update(file-&gt;digest, (unsigned char *)hexstring, strlen(hexstring));</span>
<span class="lineNum">    1771 </span><span class="lineCov">        504 :             rm_log_debug(&quot;%s=%s was read from cache.\n&quot;, hexstring, file_path);</span>
<span class="lineNum">    1772 </span>            :         } else {
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :             rm_log_warning_line(</span>
<span class="lineNum">    1774 </span>            :                 &quot;Unable to read external checksum from interal cache for %s&quot;, file_path);
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :             file-&gt;has_ext_cksum = 0;</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :             file-&gt;shred_group-&gt;has_only_ext_cksums = 0;</span>
<span class="lineNum">    1777 </span>            :         }
<span class="lineNum">    1778 </span><span class="lineCov">      66566 :     } else if(file-&gt;shred_group-&gt;digest_type == RM_DIGEST_PARANOID) {</span>
<span class="lineNum">    1779 </span>            :         /* check if memory allocation is ok */
<span class="lineNum">    1780 </span><span class="lineCov">      19745 :         if(!rm_shred_check_hash_mem_alloc(file-&gt;shred_group, 0)) {</span>
<span class="lineNum">    1781 </span><span class="lineCov">       1227 :             can_process = false;</span>
<span class="lineNum">    1782 </span>            :         } else {
<span class="lineNum">    1783 </span>            :             /* get the required target offset into file-&gt;shred_group-&gt;next_offset, so
<span class="lineNum">    1784 </span>            :                 * that we can make the paranoid RmDigest the right size*/
<span class="lineNum">    1785 </span><span class="lineCov">      18518 :             if(file-&gt;shred_group-&gt;next_offset == 0) {</span>
<span class="lineNum">    1786 </span><span class="lineCov">       3437 :                 (void)rm_shred_get_read_size(file, main);</span>
<span class="lineNum">    1787 </span>            :             }
<span class="lineNum">    1788 </span><span class="lineCov">      18518 :             g_assert(file-&gt;shred_group-&gt;hash_offset == file-&gt;hash_offset);</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span><span class="lineCov">      18518 :             if(file-&gt;is_symlink) {</span>
<span class="lineNum">    1791 </span><span class="lineCov">        121 :                 file-&gt;digest = rm_digest_new(main-&gt;session-&gt;cfg-&gt;checksum_type, 0, 0,</span>
<span class="lineNum">    1792 </span>            :                                              PATH_MAX + 1 /* max size of a symlink file */
<span class="lineNum">    1793 </span>            :                                              );
<span class="lineNum">    1794 </span>            :             } else {
<span class="lineNum">    1795 </span><span class="lineCov">      18397 :                 file-&gt;digest =</span>
<span class="lineNum">    1796 </span><span class="lineCov">      18397 :                     rm_digest_new(main-&gt;session-&gt;cfg-&gt;checksum_type, 0, 0,</span>
<span class="lineNum">    1797 </span><span class="lineCov">      18397 :                                   file-&gt;shred_group-&gt;next_offset - file-&gt;hash_offset);</span>
<span class="lineNum">    1798 </span>            :             }
<span class="lineNum">    1799 </span>            :         }
<span class="lineNum">    1800 </span><span class="lineCov">      46821 :     } else if(file-&gt;shred_group-&gt;digest) {</span>
<span class="lineNum">    1801 </span>            :         /* pick up the digest-so-far from the RmShredGroup */
<span class="lineNum">    1802 </span><span class="lineCov">         21 :         file-&gt;digest = rm_digest_copy(file-&gt;shred_group-&gt;digest);</span>
<span class="lineNum">    1803 </span>            :     } else {
<span class="lineNum">    1804 </span>            :         /* this is first generation of RMGroups, so there is no progressive hash yet */
<span class="lineNum">    1805 </span><span class="lineCov">      93600 :         file-&gt;digest = rm_digest_new(main-&gt;session-&gt;cfg-&gt;checksum_type,</span>
<span class="lineNum">    1806 </span><span class="lineCov">      46800 :                                      main-&gt;session-&gt;hash_seed1,</span>
<span class="lineNum">    1807 </span><span class="lineCov">      46800 :                                      main-&gt;session-&gt;hash_seed2,</span>
<span class="lineNum">    1808 </span>            :                                      0);
<span class="lineNum">    1809 </span>            :     }
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span><span class="lineCov">      67070 :     return can_process;</span>
<span class="lineNum">    1812 </span>            : }
<span class="lineNum">    1813 </span>            : 
<a name="1814"><span class="lineNum">    1814 </span>            : #define RM_SHRED_TOO_MANY_BYTES_TO_WAIT (64 * 1024 * 1024)</a>
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span><span class="lineCov">      65843 : static RmFile *rm_shred_process_file(RmShredDevice *device, RmFile *file) {</span>
<span class="lineNum">    1817 </span><span class="lineCov">      65843 :     if(file-&gt;shred_group-&gt;has_only_ext_cksums) {</span>
<span class="lineNum">    1818 </span><span class="lineCov">        504 :         rm_shred_adjust_counters(device, 0, -(gint64)file-&gt;file_size);</span>
<span class="lineNum">    1819 </span><span class="lineCov">        504 :         return file;</span>
<span class="lineNum">    1820 </span>            :     }
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span><span class="lineCov">      65339 :     bool worth_waiting = FALSE;</span>
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span><span class="lineCov">      65339 :     g_mutex_lock(&amp;file-&gt;shred_group-&gt;lock);</span>
<span class="lineNum">    1825 </span>            :     {
<span class="lineNum">    1826 </span><span class="lineCov">     130678 :         worth_waiting = device-&gt;main-&gt;session-&gt;cfg-&gt;shred_always_wait ||</span>
<span class="lineNum">    1827 </span><span class="lineCov">      67220 :                         (device-&gt;is_rotational &amp;&amp;</span>
<span class="lineNum">    1828 </span><span class="lineCov">       3586 :                          file-&gt;seek_offset + rm_shred_get_read_size(file, device-&gt;main) !=</span>
<span class="lineNum">    1829 </span><span class="lineCov">       3586 :                              file-&gt;file_size &amp;&amp;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :                          rm_shred_get_read_size(file, device-&gt;main) &lt;</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :                              RM_SHRED_TOO_MANY_BYTES_TO_WAIT &amp;&amp;</span>
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :                          (file-&gt;status == RM_FILE_STATE_NORMAL) &amp;&amp;</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :                          !device-&gt;main-&gt;session-&gt;cfg-&gt;shred_never_wait);</span>
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span><span class="lineCov">      65339 :     g_mutex_unlock(&amp;file-&gt;shred_group-&gt;lock);</span>
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :     /* hash the next increment of the file */
<span class="lineNum">    1838 </span><span class="lineCov">      65339 :     file-&gt;devlist_waiting = worth_waiting;</span>
<span class="lineNum">    1839 </span><span class="lineCov">      65339 :     if(file-&gt;is_symlink) {</span>
<span class="lineNum">    1840 </span><span class="lineCov">        264 :         rm_shred_readlink_factory(file, device);</span>
<span class="lineNum">    1841 </span>            :     } else {
<span class="lineNum">    1842 </span><span class="lineCov">      65075 :         if(device-&gt;main-&gt;session-&gt;cfg-&gt;use_buffered_read) {</span>
<span class="lineNum">    1843 </span><span class="lineCov">       1697 :             rm_shred_buffered_read_factory(file, device);</span>
<span class="lineNum">    1844 </span>            :         } else {
<span class="lineNum">    1845 </span><span class="lineCov">      63378 :             rm_shred_unbuffered_read_factory(file, device);</span>
<span class="lineNum">    1846 </span>            :         }
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineCov">      65075 :         if(worth_waiting) {</span>
<span class="lineNum">    1849 </span>            :             /* wait until the increment has finished hashing */
<span class="lineNum">    1850 </span><span class="lineCov">       1697 :             g_assert(file == g_async_queue_pop(device-&gt;hashed_file_return));</span>
<span class="lineNum">    1851 </span>            :         } else {
<span class="lineNum">    1852 </span><span class="lineCov">      63378 :             file = NULL;</span>
<span class="lineNum">    1853 </span>            :         }
<span class="lineNum">    1854 </span>            :     }
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span><span class="lineCov">      65339 :     return file;</span>
<a name="1857"><span class="lineNum">    1857 </span>            : }</a>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span><span class="lineCov">      67070 : static bool rm_shred_can_process(RmFile *file, RmShredTag *main) {</span>
<span class="lineNum">    1860 </span>            :     /* initialise hash (or recover progressive hash so far) */
<span class="lineNum">    1861 </span><span class="lineCov">      67070 :     bool result = TRUE;</span>
<span class="lineNum">    1862 </span><span class="lineCov">      67070 :     g_assert(file-&gt;shred_group);</span>
<span class="lineNum">    1863 </span><span class="lineCov">      67070 :     g_mutex_lock(&amp;file-&gt;shred_group-&gt;lock);</span>
<span class="lineNum">    1864 </span>            :     {
<span class="lineNum">    1865 </span><span class="lineCov">      67070 :         if(file-&gt;digest == NULL) {</span>
<span class="lineNum">    1866 </span><span class="lineCov">      67070 :             g_assert(file-&gt;shred_group);</span>
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span><span class="lineCov">      67070 :             result = rm_shred_reassign_checksum(main, file);</span>
<span class="lineNum">    1869 </span>            :         }
<span class="lineNum">    1870 </span>            :     }
<span class="lineNum">    1871 </span><span class="lineCov">      67070 :     g_mutex_unlock(&amp;file-&gt;shred_group-&gt;lock);</span>
<span class="lineNum">    1872 </span><span class="lineCov">      67070 :     return result;</span>
<a name="1873"><span class="lineNum">    1873 </span>            : }</a>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineCov">      25148 : static void rm_shred_devlist_factory(RmShredDevice *device, RmShredTag *main) {</span>
<span class="lineNum">    1876 </span><span class="lineCov">      25148 :     GList *iter = NULL;</span>
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span><span class="lineCov">      25148 :     g_assert(device);</span>
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span><span class="lineCov">      25148 :     g_mutex_lock(&amp;device-&gt;lock);</span>
<span class="lineNum">    1881 </span>            :     {
<span class="lineNum">    1882 </span><span class="lineCov">      25148 :         rm_log_debug(BLUE</span>
<span class="lineNum">    1883 </span>            :                      &quot;Started rm_shred_devlist_factory for disk %s (%u:%u) with %&quot; LLU
<span class="lineNum">    1884 </span>            :                      &quot; files in queue\n&quot; RESET,
<span class="lineNum">    1885 </span>            :                      device-&gt;disk_name,
<span class="lineNum">    1886 </span>            :                      major(device-&gt;disk),
<span class="lineNum">    1887 </span>            :                      minor(device-&gt;disk),
<span class="lineNum">    1888 </span>            :                      (RmOff)g_queue_get_length(device-&gt;file_queue));
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineCov">      25150 :         if(device-&gt;is_rotational) {</span>
<span class="lineNum">    1891 </span><span class="lineCov">       2283 :             g_queue_sort(device-&gt;file_queue,</span>
<span class="lineNum">    1892 </span>            :                          (GCompareDataFunc)rm_shred_compare_file_order, NULL);
<span class="lineNum">    1893 </span>            :         }
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span><span class="lineCov">      25150 :         if(g_queue_get_length(device-&gt;file_queue) == 0 &amp;&amp; device-&gt;remaining_files &gt; 0) {</span>
<span class="lineNum">    1896 </span>            :             /* give the other device threads a chance to catch up, which will hopefully
<span class="lineNum">    1897 </span>            :              * release held files from RmShredGroups to give us some work to do */
<span class="lineNum">    1898 </span><span class="lineCov">      11485 :             gint64 end_time = g_get_monotonic_time() + SHRED_EMPTYQUEUE_SLEEP_US;</span>
<span class="lineNum">    1899 </span><span class="lineCov">      11485 :             g_cond_wait_until(&amp;device-&gt;change, &amp;device-&gt;lock, end_time);</span>
<span class="lineNum">    1900 </span>            :         }
<span class="lineNum">    1901 </span><span class="lineCov">      25150 :         iter = device-&gt;file_queue-&gt;head;</span>
<span class="lineNum">    1902 </span>            :     }
<span class="lineNum">    1903 </span><span class="lineCov">      25150 :     g_mutex_unlock(&amp;device-&gt;lock);</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :     /* scheduler for one file at a time, optimised to minimise seeks */
<span class="lineNum">    1906 </span><span class="lineCov">     117369 :     while(iter &amp;&amp; !rm_session_was_aborted(main-&gt;session)) {</span>
<span class="lineNum">    1907 </span><span class="lineCov">      67069 :         RmFile *file = iter-&gt;data;</span>
<span class="lineNum">    1908 </span><span class="lineCov">      67069 :         gboolean can_process = rm_shred_can_process(file, main);</span>
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span>            :         /* remove current iter from queue and move to next in preparation for next file*/
<span class="lineNum">    1911 </span><span class="lineCov">      67070 :         g_mutex_lock(&amp;device-&gt;lock);</span>
<span class="lineNum">    1912 </span>            :         {
<span class="lineNum">    1913 </span><span class="lineCov">      67070 :             GList *tmp = iter;</span>
<span class="lineNum">    1914 </span><span class="lineCov">      67070 :             iter = iter-&gt;next;</span>
<span class="lineNum">    1915 </span><span class="lineCov">      67070 :             if(can_process) {</span>
<span class="lineNum">    1916 </span>            :                 /* file will be processed */
<span class="lineNum">    1917 </span><span class="lineCov">      65843 :                 g_queue_delete_link(device-&gt;file_queue, tmp);</span>
<span class="lineNum">    1918 </span>            :             }
<span class="lineNum">    1919 </span>            :         }
<span class="lineNum">    1920 </span><span class="lineCov">      67070 :         g_mutex_unlock(&amp;device-&gt;lock);</span>
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span><span class="lineCov">     199984 :         while(can_process) {</span>
<span class="lineNum">    1923 </span><span class="lineCov">      65843 :             can_process = FALSE;</span>
<span class="lineNum">    1924 </span><span class="lineCov">      65843 :             RmOff start_offset = file-&gt;hash_offset;</span>
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineCov">      65843 :             file = rm_shred_process_file(device, file);</span>
<span class="lineNum">    1927 </span><span class="lineCov">      65843 :             if(file) {</span>
<span class="lineNum">    1928 </span><span class="lineCov">       2465 :                 if(start_offset == file-&gt;hash_offset &amp;&amp; file-&gt;has_ext_cksum == false) {</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :                     rm_log_debug(RED &quot;Offset stuck at %&quot; LLU &quot;\n&quot; RESET, start_offset);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                     file-&gt;status = RM_FILE_STATE_IGNORE;</span>
<span class="lineNum">    1931 </span>            :                     /* rm_shred_sift will dispose of the file */
<span class="lineNum">    1932 </span>            :                 }
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span><span class="lineCov">       2465 :                 if(file-&gt;status == RM_FILE_STATE_FRAGMENT) {</span>
<span class="lineNum">    1935 </span>            : /* file is not ready for checking yet; push it back into the queue */
<span class="lineNum">    1936 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1937 </span>            :                     RM_DEFINE_PATH(file);
<span class="lineNum">    1938 </span>            :                     rm_log_debug(&quot;Recycling fragment %s\n&quot;, file_path);
<span class="lineNum">    1939 </span>            : #endif
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                     rm_shred_push_queue_sorted(file); /* call with device unlocked */</span>
<span class="lineNum">    1941 </span><span class="lineCov">       2465 :                 } else if(rm_shred_sift(file)) {</span>
<span class="lineNum">    1942 </span>            : /* continue hashing same file, ie no change to iter */
<span class="lineNum">    1943 </span>            : #if _RM_SHRED_DEBUG
<span class="lineNum">    1944 </span>            :                     RM_DEFINE_PATH(file);
<span class="lineNum">    1945 </span>            :                     rm_log_debug(&quot;Continuing to next generation %s\n&quot;, file_path);
<span class="lineNum">    1946 </span>            : #endif
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :                     can_process = rm_shred_can_process(file, main);</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :                     if(!can_process) {</span>
<span class="lineNum">    1949 </span>            :                         /* put file back in queue */
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :                         rm_shred_push_queue(file);</span>
<span class="lineNum">    1951 </span>            :                     }
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1953 </span>            :                 } else {
<span class="lineNum">    1954 </span>            :                     /* rm_shred_sift has taken responsibility for the file and either
<span class="lineNum">    1955 </span>            :                      * disposed
<span class="lineNum">    1956 </span>            :                      * of it or pushed it back into our queue */
<span class="lineNum">    1957 </span>            :                 }
<span class="lineNum">    1958 </span>            :             }
<span class="lineNum">    1959 </span>            :         }
<span class="lineNum">    1960 </span>            :     }
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            :     /* threadpool thread terminates but the device will be recycled via
<span class="lineNum">    1963 </span>            :      * the device_return queue
<span class="lineNum">    1964 </span>            :      */
<span class="lineNum">    1965 </span><span class="lineCov">      25150 :     rm_log_debug(BLUE &quot;Pushing device back to main joiner %d\n&quot; RESET, (int)device-&gt;disk);</span>
<span class="lineNum">    1966 </span><span class="lineCov">      25150 :     g_async_queue_push(main-&gt;device_return, device);</span>
<a name="1967"><span class="lineNum">    1967 </span><span class="lineCov">      25150 : }</span></a>
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span><span class="lineCov">      13188 : static void rm_shred_create_devpool(RmShredTag *tag, GHashTable *dev_table) {</span>
<span class="lineNum">    1970 </span><span class="lineCov">      26376 :     tag-&gt;device_pool = rm_util_thread_pool_new(</span>
<span class="lineNum">    1971 </span>            :         (GFunc)rm_shred_devlist_factory, tag,
<span class="lineNum">    1972 </span><span class="lineCov">      26376 :         MIN(tag-&gt;session-&gt;cfg-&gt;threads / 2 + 1, g_hash_table_size(dev_table)));</span>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            :     GHashTableIter iter;
<span class="lineNum">    1975 </span>            :     gpointer key, value;
<span class="lineNum">    1976 </span><span class="lineCov">      13188 :     g_hash_table_iter_init(&amp;iter, dev_table);</span>
<span class="lineNum">    1977 </span><span class="lineCov">      39426 :     while(g_hash_table_iter_next(&amp;iter, &amp;key, &amp;value)) {</span>
<span class="lineNum">    1978 </span><span class="lineCov">      13050 :         RmShredDevice *device = value;</span>
<span class="lineNum">    1979 </span><span class="lineCov">      13050 :         device-&gt;after_preprocess = true;</span>
<span class="lineNum">    1980 </span><span class="lineCov">      13050 :         g_queue_sort(device-&gt;file_queue, (GCompareDataFunc)rm_shred_compare_file_order,</span>
<span class="lineNum">    1981 </span>            :                      NULL);
<span class="lineNum">    1982 </span><span class="lineCov">      13050 :         rm_log_debug(GREEN &quot;Pushing device %s to threadpool\n&quot;, device-&gt;disk_name);</span>
<span class="lineNum">    1983 </span><span class="lineCov">      13050 :         rm_util_thread_pool_push(tag-&gt;device_pool, device);</span>
<span class="lineNum">    1984 </span>            :     }
<a name="1985"><span class="lineNum">    1985 </span><span class="lineCov">      13188 : }</span></a>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineCov">     216532 : static void rm_shred_hash_pool_free(GThreadPool *hash_pool) {</span>
<span class="lineNum">    1988 </span><span class="lineCov">     216532 :     g_thread_pool_free(hash_pool, FALSE, TRUE);</span>
<a name="1989"><span class="lineNum">    1989 </span><span class="lineCov">     216532 : }</span></a>
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span><span class="lineCov">      13188 : void rm_shred_run(RmSession *session) {</span>
<span class="lineNum">    1992 </span><span class="lineCov">      13188 :     g_assert(session);</span>
<span class="lineNum">    1993 </span><span class="lineCov">      13188 :     g_assert(session-&gt;tables);</span>
<span class="lineNum">    1994 </span><span class="lineCov">      13188 :     g_assert(session-&gt;mounts);</span>
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span>            :     RmShredTag tag;
<span class="lineNum">    1997 </span><span class="lineCov">      13188 :     tag.active_groups = 0;</span>
<span class="lineNum">    1998 </span><span class="lineCov">      13188 :     tag.hash_mem_alloc = session-&gt;cfg-&gt;paranoid_mem;</span>
<span class="lineNum">    1999 </span><span class="lineCov">      13188 :     tag.session = session;</span>
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :     /* Do not rely on sizeof(RmBuffer), compiler might add padding. */
<span class="lineNum">    2002 </span><span class="lineCov">      13188 :     tag.mem_pool = rm_buffer_pool_init(offsetof(RmBuffer, data) + SHRED_PAGE_SIZE);</span>
<span class="lineNum">    2003 </span><span class="lineCov">      13188 :     tag.device_return = g_async_queue_new();</span>
<span class="lineNum">    2004 </span><span class="lineCov">      13188 :     tag.page_size = SHRED_PAGE_SIZE;</span>
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span>            :     /* would use g_atomic, but helgrind does not like that */
<span class="lineNum">    2007 </span><span class="lineCov">      13188 :     g_mutex_init(&amp;tag.hash_mem_mtx);</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineCov">      13188 :     session-&gt;tables-&gt;dev_table = g_hash_table_new_full(</span>
<span class="lineNum">    2010 </span>            :         g_direct_hash, g_direct_equal, NULL, (GDestroyNotify)rm_shred_device_free);
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineCov">      13188 :     rm_shred_preprocess_input(&amp;tag);</span>
<span class="lineNum">    2013 </span><span class="lineCov">      13188 :     session-&gt;shred_bytes_after_preprocess = session-&gt;shred_bytes_remaining;</span>
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span>            :     /* Remember how many devlists we had - so we know when to stop */
<span class="lineNum">    2016 </span><span class="lineCov">      13188 :     int devices_left = g_hash_table_size(session-&gt;tables-&gt;dev_table);</span>
<span class="lineNum">    2017 </span><span class="lineCov">      13188 :     rm_log_debug(BLUE &quot;Devices = %d\n&quot;, devices_left);</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span>            :     /* Create a pool for results processing */
<span class="lineNum">    2020 </span><span class="lineCov">      13188 :     tag.result_pool = rm_util_thread_pool_new((GFunc)rm_shred_result_factory, &amp;tag, 1);</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     /* Create a pool of hashing threadpools */
<span class="lineNum">    2023 </span><span class="lineCov">      13188 :     tag.hash_pool_pool = g_async_queue_new_full((GDestroyNotify)rm_shred_hash_pool_free);</span>
<span class="lineNum">    2024 </span><span class="lineCov">      13188 :     g_assert(session-&gt;cfg-&gt;threads &gt; 0);</span>
<span class="lineNum">    2025 </span><span class="lineCov">     229720 :     for(uint i = 0; i &lt; session-&gt;cfg-&gt;threads / 2 + 1; i++) {</span>
<span class="lineNum">    2026 </span><span class="lineCov">     216532 :         g_async_queue_push(</span>
<span class="lineNum">    2027 </span>            :             tag.hash_pool_pool,
<span class="lineNum">    2028 </span><span class="lineCov">     216532 :             rm_util_thread_pool_new((GFunc)rm_shred_hash_factory, &amp;tag, 1));</span>
<span class="lineNum">    2029 </span>            :     }
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span>            :     /* Create a pool fo the devlists and push each queue */
<span class="lineNum">    2032 </span><span class="lineCov">      13188 :     rm_shred_create_devpool(&amp;tag, session-&gt;tables-&gt;dev_table);</span>
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            :     /* This is the joiner part */
<span class="lineNum">    2035 </span><span class="lineCov">      13188 :     while(devices_left &gt; 0 || g_async_queue_length(tag.device_return) &gt; 0) {</span>
<span class="lineNum">    2036 </span><span class="lineCov">      25150 :         RmShredDevice *device = g_async_queue_pop(tag.device_return);</span>
<span class="lineNum">    2037 </span><span class="lineCov">      25150 :         g_mutex_lock(&amp;device-&gt;lock);</span>
<span class="lineNum">    2038 </span><span class="lineCov">      25150 :         g_mutex_lock(&amp;tag.hash_mem_mtx);</span>
<span class="lineNum">    2039 </span>            :         {
<span class="lineNum">    2040 </span>            :             /* probably unnecessary because we are only reading */
<span class="lineNum">    2041 </span><span class="lineCov">      25150 :             rm_log_debug(BLUE &quot;Got device %s back with %d in queue and %&quot; LLU</span>
<span class="lineNum">    2042 </span>            :                               &quot; bytes remaining in %d remaining files; active groups %d &quot;
<span class="lineNum">    2043 </span>            :                               &quot;and avail mem %&quot; LLU &quot;\n&quot; RESET,
<span class="lineNum">    2044 </span>            :                          device-&gt;disk_name,
<span class="lineNum">    2045 </span>            :                          g_queue_get_length(device-&gt;file_queue),
<span class="lineNum">    2046 </span>            :                          device-&gt;remaining_bytes,
<span class="lineNum">    2047 </span>            :                          device-&gt;remaining_files,
<span class="lineNum">    2048 </span>            :                          tag.active_groups,
<span class="lineNum">    2049 </span>            :                          tag.hash_mem_alloc);
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span><span class="lineCov">      25150 :             if(device-&gt;remaining_files &gt; 0) {</span>
<span class="lineNum">    2052 </span>            :                 /* recycle the device */
<span class="lineNum">    2053 </span><span class="lineCov">      12100 :                 rm_util_thread_pool_push(tag.device_pool, device);</span>
<span class="lineNum">    2054 </span>            :             } else {
<span class="lineNum">    2055 </span><span class="lineCov">      13050 :                 devices_left--;</span>
<span class="lineNum">    2056 </span>            :             }
<span class="lineNum">    2057 </span>            :         }
<span class="lineNum">    2058 </span><span class="lineCov">      25150 :         g_mutex_unlock(&amp;tag.hash_mem_mtx);</span>
<span class="lineNum">    2059 </span><span class="lineCov">      25150 :         g_mutex_unlock(&amp;device-&gt;lock);</span>
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineCov">      25150 :         if(rm_session_was_aborted(session)) {</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2063 </span>            :         }
<span class="lineNum">    2064 </span>            :     }
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineCov">      13188 :     g_async_queue_unref(tag.hash_pool_pool);</span>
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span><span class="lineCov">      13188 :     session-&gt;shredder_finished = TRUE;</span>
<span class="lineNum">    2069 </span><span class="lineCov">      13188 :     rm_fmt_set_state(session-&gt;formats, RM_PROGRESS_STATE_SHREDDER);</span>
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span>            :     /* This should not block, or at least only very short. */
<span class="lineNum">    2072 </span><span class="lineCov">      13188 :     g_thread_pool_free(tag.device_pool, FALSE, TRUE);</span>
<span class="lineNum">    2073 </span><span class="lineCov">      13188 :     g_thread_pool_free(tag.result_pool, FALSE, TRUE);</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span><span class="lineCov">      13188 :     g_async_queue_unref(tag.device_return);</span>
<span class="lineNum">    2076 </span><span class="lineCov">      13188 :     rm_buffer_pool_destroy(tag.mem_pool);</span>
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span><span class="lineCov">      13188 :     g_hash_table_unref(session-&gt;tables-&gt;dev_table);</span>
<span class="lineNum">    2079 </span><span class="lineCov">      13188 :     g_mutex_clear(&amp;tag.hash_mem_mtx);</span>
<span class="lineNum">    2080 </span><span class="lineCov">      13188 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
