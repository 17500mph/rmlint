rmlint is a command line tool to remove various sort of unused files form a Unix filesystem, especially duplicate files.
It comes without any extra depencies, and is build to handle even large filesystems pretty fast.  
It is written in pure ANSI C, and comes with as size of 36KB. 

DISCLAIMER: 
THERE IS NO WARRANTY THAT THIS SOFTWARE WON'T KILL YOUR FILES, NOR THAT IT KILLS YOUR KITTEN, BURNS YOUR HOUSE, OR WHATSOEVER. 
IT WAS written carefully and in the hope it'll will be useful for some messy users. 

INSTALL: 
--------
The usual mantra: 

make -j 4 
sudo make install 

COMPARASION TO OTHER TOOLS: 
--------------------------
(this list could get very, very long..) 

compared to... 
	..fdupes / duff: 
		+ LOTS faster	
		+ more options 
		+ finds also bad links 
		+ logging

	..rdfind: 
		+ Live output of finds
		+ mostly as fast, or faster
		+ little less buggy ;-) 
		- handles large folders with lots of files not as good.
		
	..fslint: 
		+ Faster / more options 
		- finds no stripped binaries, old tmpdata, etc. (ToDo?) 
		
	..[other cons] 
		- does not look into archives (things like those could be performed by some bash script easier)
		
		
Pseudobenchmark on 60GB Music: 
------------------------------
rdfind: 8:01  min. | 7:55  min | 7:49  min += 23:45 min
rmlint: 7:52  min  | 8:33  min | 7:02  min += 23:27 min  
fdupes: 16:04 min  | 14:24 min | 14:07 min += 44:35 min 

Benchmark was on a EeePc 1015HP ;-) 
On a recent quadcoremachine things will get lot's faster.

HELP: 
------------
- This Readme.
- rmlint -h 
- man rmlint  

OPTIONS:
---------
Syntax: rmlint [TargetDir[s]] [File[s]] [Options]

General options:

	-t --threads <t>	Set the number of threads to <t> used in full checksum creation.
	-p --paranoid		Do a byte-by-byte comparasion additionally. (Slow!)
	-d --maxdepth <depth>	Only recurse up to this depth. (default: inf)
	-f --followlinks	Wether links are followed (None is reported twice) [Only specify this if you really need to]
	-s --samepart		Never cross mountpoints, stay on the same partition
	-G --hidden		Also search through hidden files / directories (disabled by default)
	-m --mode <mode>	Tell rmlint how to deal with the files it finds.

				Where modes are:

				list  - Only list found files and exit.
				link  - Replace file with a hard link to original.
				ask   - Ask for each file what to do
				noask - Full removal without asking.
				cmd   - Takes the command given by -c and executes it on the file.

	-c --cmd_dup  <cmd>	Execute a shellcommand on found duplicates when used with '-m cmd'
	-C --cmd_orig <cmd>	Execute a shellcommand on original files when used with '-m cmd'

				Example: rmlint testdir -m cmd -C "ls '%s'" -c "ls -lasi '%s'" -v 1
				This would print all found files (both duplicates and originals via the 'ls' utility
				The %s expands to the found duplicate, second to the 'original'.
Regex options:

	-r --fregex <pat>	Checks filenames against the pattern <pat>
	-R --dregex <pat>	Checks dirnames against the pattern <pat>
	-i --invmatch		Invert match - Only investigate when not containing <pat>
	-e --matchcase		Matches case of paths (not by default)

Misc options:

	-h --help		Prints this text and exits
	-o --output [<o>]	Outputs logfile to <o>. The <o> argument is optional, specify none to write no log.
				Examples:

				-o => No Logfile
				-o="la la.txt" => Logfile to "la la.txt"

				Note that you NEED the '=' here.

	-z --dump <id>		Option with various weird meanings, most scientist postulated that it kills kittens.
	-v --verbosity <v>	Sets the verbosity level to <v>
				Where:
				0 prints nothing
				1 prints only errors and results
				2 + prints warning
				3 + everything else

Additionally, the options p,f,s,e,g,o,i,c have a uppercase option (O,G,P,F,S,E,I,C) that inverse it's effect.



FEATURES:
--------
- Can be aborted at any time. Will display all finds then. (or abort immediately if user presses CTRL-C once more) 
- Fast. (Really! :)) 
- Regex filter. 
- Colorful! :-) (can be compiled without colors support if you like to) 
- Can handle huge amount of files. 
- Handles the files the way you want: 
   + replace double file by a symboliclink, (-m link)  
   + Removes the file without asking you. (-m noask) 
   + Simply list all files without doing anything dangerous. (-m list) 
   + It executes a user specified commando for each file (-m cmd) 
   + It asks you for each file what you want. (-m ask)
- Minimum of I/O, focuses on CPU usage. 
- It has some basic "API" (Well, let's just say you can exec it from your program :-)) 
- Writes a log of all found files (./rmlint.sh or name by --output) or outputs a ready to use script  


HOW DOES THIS WEIRD THING WORK: 
-------------------------------
rmlint tries to reduce Input/Output to a minimum and focues on CPU Usage.
Therefore it goes recursively through all directories and pushes all files back to a doubly linked list. 
This list is now split in several groups: Every size get's it's own group, and groups with only one element are dropped.
Empty files and bad links are handled on this way too. (they build a group with a size of 0 ;))  
Now every group is given to a sheduler which filters each group by portions of the file, and builds md5sum on each survivor.
Note that several groups may get processed in parallel!  A log of all files is written to a file called 'rmlint.sh' (name changeable with '--output'). 
Additionally it may handle finds by removeing them, linking them to the original or executing some shellcommand on them. 



A NOTE ABOUT FALSE POSITIVES: 
-----------------------------
False Positves are actuallly possible, but very unlikely. 
A so-called collision has about a probability (under best conditions) of 1/(255^16) + 
They would need to have the same size to be marked as duplicate.  
=> Very unlikely, but possible.

But isn't there a solution? Yes, there is. It's the "--paranoid/-p" option. It does a 
true byte-by-byte comparasion of each(!) file. Be warned. It's incredibly slow. 


FAQ: 
----
Q: The "-m list" output is crap! I want more information! 
A: You can use the command mode to use to run 'ls' on the files: 
   Example: time ./rmlint . -m cmd -c "ls -lasi '%s'" -C "ls '%s'" -v 1
   Where -c executes "ls -lasi" on the found duplicate, -C on the original. 
     
Q: I want only the found files to be displayed! Like fdupes does! 
A: "-v 1" is your friend.
