
- RMLINT -
----------

rmlint is a commandline tool to clean your filesystem from various sort of lint (unused files, twins, etc.).
It was mainly written for Unix-like Operating Systems, but should also work on Mac OSX, and to some degree
on MS Windows (not tested). Rmlint comes without any extra dependencies, and is build to handle even large filesystems pretty fast.  

DISCLAIMER: 
THERE IS NO WARRANTY THAT THIS SOFTWARE WON'T KILL YOUR FILES, 
NOR THAT IT KILLS YOUR KITTEN, BURNS YOUR HOUSE, OR WHATSOEVER. 
NONETHELESS IT WAS WRITTEN VERY CAREFULLY AND SHOULD DO WHAT 
IT IS SUPPOSED TO DO.

INSTALL: 
--------

## DOWNLOAD

# Git way
git clone https://github.com/sahib/rmlint.git 

# OR

# Zip way
wget --no-check-certificate http://github.com/sahib/rmlint/zipball/master -O rmlint.zip
unzip rmlint.zip

# OR

# Tar way
wget --no-check-certificate http://github.com/sahib/rmlint/tarball/master -O rmlint.tar
tar xfv rmlint.tar

# compile it
cd <name_of_the_dir>
./configure
make -j 4 
sudo make install 

HELP: 
------------
Use: 
- 'rmlint -h'
- 'man rmlint' 


FEATURES:
---------

- Very fast (written in pure C, in many cases faster than rdfind, and always magnitudes faster than fdupes).
- Output of both a ready to use script to handle finds and a easy-to-parse logfile.
- Tries to minimize I/O as much as possible (focus on CPU-usage).
- Finds duplictes, nonstripped binaries, files with same basenames (nameclusters), empty files/directories, old tempdata, strange filenames and bad links.
- Displays finds in realtime. (like 'duff' or 'fdupes')
- Safely abortable at any time (will write log & script).
- No extra dependencies at all (glibc2 and pthread is something you already have).
- Colorful output (can be disabled via -B).
- Regex filter for both files and directories. 
- Handles the files the way you want: 
   + replace double file by a symboliclink, (-m link)  
   + Removes the file without asking you. (-m noask) 
   + Simply list all files without doing anything dangerous. (-m list) 
   + It executes a user specified commando for each file (-m cmd) 
   + It asks you for each file what you want (added for convinience only to be honest). (-m ask)

What it does internally (Algorithm): 
-------------------------------------
The algorithm tries to mimize IO as far as possible, thus focusing on CPU usage. (can get up to 390% on a quadcore)
1) Go through all directories and catch all files conformig to regexpattern / dirpattern / hiddenstatus
2) lint other than duplicates get detected here on the fly (like nonstripped binaries - every file is checked)
3) the rest of the list (all files without files from 2)) gets sorted by their filesize
4) elements with a unique filesize gets kicked out (because they can't have a twin)
5) list gets divided isn sublist, each size one sublist
6) each sublist gets sort by inode (to speed up reading from HD)
7) Each group is processed seperately:
  7.1) if the size of group exceeds a certain limit then it's processed on an own thread
  7.2) else the group gets processed within the main thread

8) Processing: For each file of a group..
  8.1) A short fingerprint from the start/end + some bytes in the middle of the file is read and stored
  8.2) Nonmatching files get kicked out, if the group consists of 1 elem or less, rmlint forgets about it
  8.3) a md5sums are calculated for the rest of the group (only the part of the file that hasnt been read, is used fo md5sum calculation)
  8.4) if the groupssize exceeds a certain limit, the group gets splitted into several equalsized subgroups
     8.4.1) The whole file is read blockwise, while other threads have wait (so no useless jumping is done)
     8.4.2) After a block is read (blocksize is about 2MB) md5 is updated, while at the same time another thread is reading, back to 8.3.1)
  8.4) md5sums, filesize, fingerprint and bytes in the middle get checked each other (to double check and prevent false positives) 
  8.5) log/handle result to script / log / screen (let other threads wait for this short time, so no chaos is created)
9) Do for every group, and print statistics


RMLINT IS KNOWN FINE TO RUN ON THOSE PLATFORMS:
----------------------------------------------
- Linux 32/64
- Solaris

Note1: It is written in ANSI C, so every ANSI C compiler should be happily compile it. 
Note2: rmlint uses alloca(), if you want to port it you may need to replace it with malloc() (and a corresponding free())

A NOTE ABOUT FALSE POSITIVES: 
-----------------------------
Short: False Positves are actuallly possible, but very, very, very unlikely. 
They would need to have the same size, fingerprint and checksums to be marked as twins.
md5 is not perfect, but the probability of getting false positves on a normal set of data is the same as lim(1/x) : x -> +inf = 0 + h; where h ~ 0

But isn't there a solution to be 100% sure? Yes, there is. It's the "--paranoid/-p" option. It does a 
true byte-by-byte comparasion of each(!) file. Be warned, because it's incredibly slow. 

If you find false-positives, those are most likely a bug on rmlint, please make a bugreport to sahib@online.de in this case,
so others won't suffer from it.


COMPARASION TO OTHER TOOLS: 
---------------------------
(this list could get very, very long..) 

compared to... 
	..fdupes / duff: 
		+ LOTS faster 	
		+ more options 
		+ finds also bad links and other stuff 
		+ logging
                - did find one file more once. :-)

	..rdfind: 
		+ Live output of finds
		+ mostly as fast, or faster
		+ little less buggy ;-) 
		- rdfind is faster with many small files (like Sourcedirs)
		
	..fslint: 
		+ Faster / more options 
		- fslint finds also borken UID/GIDs (this never happened to me, anyone?)
		
	..[other cons] 
		- does not look into archives (things like those could be performed by some bash script easier)
		- no gui (some people mark this as a clear '+')
		
		
Pseudobenchmark: 
----------------

Machine was my maindesktop, quadcore, running Linx x86_64
measured was with the 2nd,3rd & 4th run of the programs

approx. time in seconds  : |   rdfind  |  rmlint |  fdupes |
---------------------------+-----------+---------+---------+
88GB of various Documents: |   1,430   |  0.656  |  8.317  | (note: rmlint's CPU Usage was 310%, rdind's 99%)
---------------------------+-----------+---------+---------+
2,2G of Source / Trees  :  |   12,03   |  1.641  |  30.552 | (note: on first run rdfind was faster) 
---------------------------+-----------+---------+---------+
50G of Music (mp3/ogg)  :  |   0.097   +  0.089  | 1:54.08 | (note: this dir did not contain any twins ;-))
-------------------------------------------------+---------+


FAQ: 
----
Q: The "-m list" output is crap! I want more information! 
A: You can use the command mode to use to run 'ls' on the files: 
   Example: ./rmlint . -m cmd -c "ls -lasi '%s'" -C "ls '%s'" -v 1
   Where -c executes "ls -lasi" on the found duplicate, -C on the original. 
     
Q: I want only the found files to be displayed! Like fdupes does! 
A: "-v 1" is your friend.

Q: I guess I found a bug, what now?
A: Great! Write me an email (sahib@online.de), with a nifty problem description and/or 
   a patch and/or any suggestions and/or a backtrace (if it was a crash)

Q: Why is there no GUI?
A: This may be on the ToDos. Perhaps. :-)

To be continued...
